单词

```js
1. debounce  防抖
2. throttle  节流
3. beforeach  路由拦截器
4. interceptors.request  请求拦截器
5. interceptors.response  响应拦截器
6. activated      触发时机：keep-alive组件激活时使用；
7. deactivated    触发时机：keep-alive组件停用时调用；
8. include  字符串或正则     只有名称匹配的组件才会被缓存
9. exclude  字符串或正则     任何名称匹配的组件都不会被缓存
   <keep-alive :include="/a|b/">
```

NextTick

- 数据驱动视图更新不是立即执行的

- 当需要在修改数据后立即操作Dom 最好放到$nextTick中

- 这个函数会在本次的数据更新视图后被调用

- 其中的代码拿到的dom 一定是更新后的 

- ```
  this.$nexttick(() => {}) 使用箭头函数
  ```

- 

# 项目

## 打包

```js
1. npm run build

```

使用 Vue 官方推荐的一个命令行 http 服务工具：[serve](https://github.com/zeit/serve)。

安装：

```sh
# yarn global add serve
npm install -g serve
```

使用：

```sh
# dist 是运行 Web 服务根目录
serve -s dist
```

> serve 默认占用 5000 端口并启动一个服务

然后在浏览器中访问给出的地址访问测试

## 项目技术

1. [Vue.js](<https://cn.vuejs.org/>)   ==>> MVVM框架
2. [Vue Router](<https://router.vuejs.org/>)  ==> 实现Vue项目的前端路由功能
3. [Vue CLI](<https://cli.vuejs.org/>)   ==> Vue项目的脚手架工具3.0
4. [Vuex](<https://vuex.vuejs.org/zh/>) ==> 状态共享框架(**`略难理解`**,根据情况) => PC项目不做 =>移动端Vuex
5. eventBus ==> **`Vuex的替代方案`**(根据课程吸收情况) 子组件 => 父组件 $emit()
6. [axios](<https://github.com/axios/axios>)  ==> 请求工具 (拦截请求)
7. [ElementUI](<https://element.eleme.io/>)  ==> Vue前端UI框架 (**`极其重要`**的知识点  工作几乎每天都用)
8. [Echarts](<https://echarts.baidu.com/>) ==> 第三方图表插件 (强大的图表插件 可在Vue中集成) 百度出品
9. [nprogress](<https://github.com/rstacruz/nprogress>)  ==>  第三方进度条(用来美化前端的页面跳转)
10. [Quill](<https://github.com/quilljs/quill>) ==> Vue第三方插件(富文本编辑器)
11. [Eslint](https://cn.eslint.org/docs/user-guide/getting-started)  ==> 语法校验辅助工具(它的目标是保证**`代码的一致性`**和**`避免错误`**)

# 登录

1. 登录页登录成功后 吧登录状态后端返回来的token存入本地

2. 用路由拦截器  一个公共页面的访问门卫 所有页面访问都必须经过这里

   ```js
   router.beforeach((to, from, next) => {
   	// 所有页面访问都要经过这里
       // 1. 如果访问的是登录页面，则直接放行
     if (to.path === '/login') {
       next()
       // 停止代码往后执行
       return
     }
   
     // 2. 非登录页面，校验登录状态
   
     // 2.1 获取用户 token
     const token = window.localStorage.getItem('user-token')
   
     // 2.2 判断是否有 token，有就通过
     if (token) {
       next()
     } else {
       // 2.3 没有，就跳转到登录页
       next('/login')
     }
   })
   ```

> 要给一个组件注册一个原生javascript事件  使用.native 修饰符

## 项目内容

1. 表单项

   1. 表单用 el-form el-form-item   按钮用 el-button   el-card   列表渲染用 el-table  下拉列表用 el-select  el-option

2. 请求模块  用axios 

    ```
   request({
   methods: ""
   url: ""
   params: {}
   }).then()
   ```

   1. 按需加载 用export   

3. 条件删选模块

   输入条件删选 不为必选项   未选择的条件 默认为后台会默认为null  渲染全部数组  不传参数 则视为请求全部

   > `axios有个功能  参数值为null时  就不传了 `

   >  `axios 不会发送值为 null、undefined 类型的参数。 `

   >  `axios.finally() 无论成功还是失败都会执行  做loading效果时会用到`

   后台返回数据有可能会超出js精确度  用json-bigint

   ```js
   try-catch  捕获异常
   将会导致报错的代码放到try 里面
   报错处理的代码放到catch里面执行
   
   ```

   在 `main.js` 中使用 axios 的请求拦截器统一添加 token：

   ```js
   // axios 请求拦截器
   axios.interceptors.request.use(function (config) {
     // 在请求拦截器函数中的 config 是本次请求相关的配置对象
     // config 就是最后要发给后端的那个配置对象
     // 我们可以在拦截器中对 config 进行统一配置定制
     console.log('请求拦截器', config)
   
     const token = window.localStorage.getItem('user-token')
   
     // 统一添加 token
     if (token) {
       config.headers.Authorization = `Bearer ${token}`
     }
   
     // return config 是通行的规则
     return config
   }, function (error) {
     // Do something with request error
     return Promise.reject(error)
   })
   ```

   

4. 城市  Object.keys(对象)   可以得到所有的键名  一个数组 用到计算属性 根据省份来获取

   ```js
   需要用到计算属性
   computed ： {
       cities () {
           let data = []
           const province = this.questionParams.province
           if(province) {
   		data = Object.keys(对象[province])   
           }
        return data
    }
   }
   
   ```

   

5. ## 搜索

   lodash.js  函数工具

   全局对象： —

    

# 1. 前端优化的方案

### 一.css优化

1.打包css文件
2.易维护：少用ID， !important，多用class
3.样式用外部样式，最好不要用行间样式，内嵌样式
4.选择器的层级最好不要超过4层，减少层级可减少渲染速度
5.可读性：类名的命名规范
6.可扩展性：css的整体设计，公用的样式抽取，减少冗余的，重复的样式
7.样式的引入放在头部

### 二.js优化

1.打包js
2.减少全局变量，全局方法的定义
3.减少闭包的使用，避免多层循环的嵌套
4.减少dom节点的事件绑定
5.删除多余的代码，公用方法的抽取
6.减少http请求次数
7.js的引用放在底部
8.避免重写，重绘次数
9.行为与页面分离：js最好写在外部文件
10.js的延迟加载 deffer

### 三.h5的优化

1.减少多余的dom节点嵌套
2.标签的语义化使用，比如标题就用h1-h6，图文列表用figure figcaption，头部用 header，底部footer，导航nav，侧边菜单栏 aside，文章用article，模块用section等
3.使用数据缓存，sessionStorage，localStorage，离线缓存，indexedDB本地数据库
4.页面SEO的优化：title、keyword、description，图片的alt，a标签的title

### 四.图片的优化

1.减小图片的的大小，小图标使用svg,png，背景图片用jpg
2.雪碧图的使用，减少对服务器的请求次数
3.图片预加载
4.字体图标的使用（阿里巴巴字体图标库IconFont）

### 五.用户体验的优化

1.加载页面，请求接口的loading
2.页面的平滑滚动，颜色的渐变，适当的动画
3.减少操作次数，减少表单输入
4.优化页面加载的速度，缓存的合理使用，预加载的使用
5.操作图标的易读性，比如说



个人中心的icon

![img](https://upload-images.jianshu.io/upload_images/9960789-e8656faec7cde07e.png?imageMogr2/auto-orient/strip|imageView2/2/w/112/format/webp)

user.png


菜单的icon

![img](https://upload-images.jianshu.io/upload_images/9960789-8a8014cfc0a81a5f.png?imageMogr2/auto-orient/strip|imageView2/2/w/120/format/webp)

menu.png

6.符合用户的行为，比如说菜单的点击放在屏幕的右边
7.搜索引擎的优化能够提升用户的访问量

# 3. 常见的兼容性问题：

- 1、不同浏览器的标签默认的外补丁( margin )和内补丁(padding)不同
  - 解决方案： css 里增加通配符 * { margin: 0; padding: 0; }
- 2、IE6双边距问题；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题
  - 解决方案：设置display:inline;
- 3、当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度
  - 解决方案：超出高度的标签设置overflow:hidden,或者设置line-height的值小于你的设置高度
- 4、图片默认有间距
  - 解决方案：使用float 为img 布局
- 5、IE9一下浏览器不能使用opacity
  - 解决方案：opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);
- 6、边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；
  - 解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；
- 7、cursor:hand 显示手型在safari 上不支持
  - 解决方案：统一使用 cursor:pointer
- 8、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；
  - 解决方案：父级元素设置position:relative

# 4. 前端性能优化

- 1、减少http请求，合理浏览器缓存
- 2、启用压缩：HTML、CSS、javascript文件启用GZip压缩可达到较好的效果
- 3、CSS Sprites：合并 CSS图片，减少请求数的又一个好办法。
- 4、LazyLoad Images：在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片
- 5、CSS放在页面最上部，javascript放在页面最下面：让浏览器尽快下载CSS渲染页面
- 6、异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）
- 7.路由懒加载
- 8.减少cookie传输

# JS深拷贝和浅拷贝的实现

1. Object.assign()实现浅拷贝及一层的深拷贝

2. 使用JSON.stringify和JSON.parse实现深拷贝：JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象；

3. 热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝；

4. jquery 提供一个`$.extend`可以用来做深拷贝；

5. ### 使用Object.create()方法

   直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。

   ```javascript
   /* ================ 深拷贝 ================ */function deepClone(initalObj, finalObj) {    var obj = finalObj || {};    for (var i in initalObj) {        var prop = initalObj[i];         // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况        if(prop === obj) {            continue;        }         if (typeof prop === 'object') {            obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);        } else {            obj[i] = prop;        }    }    return obj;}
   ```

# 6. jsonp原理（面试会碰到）

> 虽然这个方案现在用的越来越少，但是面试还是挺爱问的

1. script标签的src属性，可以发送请求，没有`同源限制`
2. 和`Ajax`一点关系都木有：
   1. `network`中选到`xhr`分类，什么都看不到
3. 本质是动态创建了一个`script`标签添加到页面顶部
   1. src设置的:`接口地址`+`发送的数据`+`callback=xxx`
4. 请求成功之后会被自动移除
5. 服务器返回了:函数的调用`函数名({对象})`
6. 内容返回到浏览器之后会被解析为`js`，调用定义好的函数，传入了一个参数

# 7. 防抖节流

- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的特性却不一样。
  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。
  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断



## 函数防抖的实现原理：

**概念：** `在事件被触发n秒后再执行，如果在这n秒内又被触发，则重新计时。`

**生活中的实例：** `如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。`

```js
function fn (foo) {
  console.log('hello', foo)
}

const newFn = debounce(fn, 1000)

// 计时 1s
newFn(123)

// 如果在 1s 之内重新调用
//   先把之前的废除
//   重新计时
newFn('world')
// newFn()


function debounce (callback, time) {
  let timer = null
  // 函数参数中的 ... 表示接收剩余参数
  // 它会把所有的参数收集到一个数组中
  return function (...args) {
    console.log(args)
    window.clearTimeout(timer)
    timer = setTimeout(() => {
      // 这里的 ... 表示数组展示操作符
      // args[0], args[1], args[2] .........
      callback(...args)
    }, time)
  }
}
```

### 函数节流（Throttle）

**概念：** `规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。`

生活中的例子：`函数节流就是开枪游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。`

### 函数节流实现原理

```js
function throttle(callback, interval) {
  // 最后一次的调用时间
  let lastTime = 0
  
  // 定时器
  let timer = null
  
  // 返回一个函数
  return function () {
    // 清除定时器
    clearTimeout(timer)

    // 当前最新时间
    let nowTime = Date.now()

    // 如果当前最新时间 - 上一次时间 >= 时间间隔
    // 或者没有上一次时间，那就立即调用
    if (nowTime - lastTime >= interval) {
      callback()

      // 记录最后一次的调用时间
      // 1
      lastTime = nowTime
    } else {
      timer = setTimeout(() => {
        callback()
      }, interval)
    }
  }
}

const fn = throttle(函数, 1000)
```

# 8. 移动端一像素问题

-  **viewport的设置和屏幕物理分辨率是按比例而不是相同的. 移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px长度映射到物理像素上就有2px或3px那么长。**

- ### # 如何解决1px问题

  ###### 1. 媒体查询利用设备像素比缩放，设置小数像素

    IOS8下已经支持带小数的px值, `media query`对应`devicePixelRatio`有个查询值`-webkit-min-device-pixel-ratio`, css可以写成这样

  

  ```css
  .border { border: 1px solid #999 }
  @media screen and (-webkit-min-device-pixel-ratio: 2) {
      .border { border: 0.5px solid #999 }
  }
  @media screen and (-webkit-min-device-pixel-ratio: 3) {
      .border { border: 0.333333px solid #999 }
  }
  ```

  【**缺点**】对设备有要求，小数像素目前兼容性较差。

  ##### 2. viewport + rem 方案

    该方案是对上述方案的优化，整体思路就是利用`viewport + rem + js` 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下：

  

  ```xml
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  
  <meta name="viewport" id="WebViewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"> 
  ```

  接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。

  

  ```dart
  var viewport = document.querySelector("meta[name=viewport]")
  if (window.devicePixelRatio == 1) {
      viewport.setAttribute('content', 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no')
  } 
  if (window.devicePixelRatio == 2) {
      viewport.setAttribute('content', 'width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no')
  } 
  if (window.devicePixelRatio == 3) {
      viewport.setAttribute('content', 'width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no')
  } 
  
  var docEl = document.documentElement;
  var fontsize = 10 * (docEl.clientWidth / 320) + 'px';
  docEl.style.fontSize = fontsize;
  ```

  【**缺点**】以为缩放涉及全局的rem单位，比较适合新项目，对于老项目可能要涉及到比较多的改动。

  ##### 3. 设置 border-image 方案

  

  ```css
  .border-image-1px {
      border-width: 1px 0px;
      -webkit-border-image: url("border.png") 2 0 stretch;
      border-image: url("border.png") 2 0 stretch;
  }
  ```

  【**解释**】`border-width` 指定边框的宽度，可以设定四个值，分别为上右下左`border-width: top right bottom left`。
   `border-image` 该例意为：距离图片上方2px（属性值上没有单位）裁剪边框图片作为上边框，下方2px裁剪作为下边框。距离左右0像素裁剪图片即没有边框，以拉伸方式展示

  结合起来就是：**在边框图片中，裁剪图片上下方的2个像素宽度作为上下边框，并展示在宽度为1个像素的边框空间里。左右没有边框。** 注意这里的1个像素是特殊的，专指物理像素，而平时设定的长宽1px则表示逻辑像素（该观点为个人理解）。

  >   你可能并没有理解，裁剪边框是什么鬼？为啥还要裁剪？`border-image`确实是个很难理解的属性，是去w3c看了之后更加蒙圈了。w3c内容提炼的太精致了，但解释根本就不够。因此奉上张鑫旭老师 [border-image详解](https://link.jianshu.com?t=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2010%2F01%2Fcss3-border-image%2F) 一文，特别要理解九宫格裁剪法。

  当然，这种方式引入了图片，我们还能将图片装换成base64形式表现

  

  ```css
  .border-image-1px {
      border-width: 1px 0px;
      -webkit-border-image: url("") 2 0 stretch;
      border-image: url('如上');
  }
  ```

  【**缺点**】需要制作图片，圆角可能出现模糊

  ##### 4. background-image 渐变实现

    除了使用图片外，当然也能使用纯css来实现，百度糯米团就是采用的这种方案。

  

  ```css
  .border {
        background-image:linear-gradient(180deg, red, red 50%, transparent 50%),
        linear-gradient(270deg, red, red 50%, transparent 50%),
        linear-gradient(0deg, red, red 50%, transparent 50%),
        linear-gradient(90deg, red, red 50%, transparent 50%);
        background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%;
        background-repeat: no-repeat;
        background-position: top, right top,  bottom, left top;
        padding: 10px;
    }
  ```

  【**思路**】将原本1个物理像素的边框大小利用线性渐变分割成几个部分（百分比控制），实现小于1像素效果
   【**解释**】`linear-gradient`指定线性渐变，接受大于等于3个参数，第一个为渐变旋转角度，第二个开始为渐变的颜色和到哪个位置（百分比）全部变为该颜色，该例子中，第一句就是，**渐变方向旋转180度，即从上往下（默认为0度从下往上），从红色开始渐变，到50%的位置还是红色，再渐变为继承父元素颜色。**
   【**缺点**】因为每个边框都是线性渐变颜色实现，因此无法实现圆角
  

  ##### 5. box-shadow 方案

  利用阴影也可以实现，优点是没有圆角问题，缺点是颜色不好控制

  

  ```css
  div {
      -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);
  }
  ```

  【**理解**】来回顾一下`box-shadow`属性的用法。

  > box-shadow: h-shadow v-shadow [blur] [spread] [color] [inset];

  参数分别表示: **水平阴影位置，垂直阴影位置，模糊距离， 阴影尺寸，阴影颜色，将外部阴影改为内部阴影**，后四个可选。该例中为何将阴影尺寸设置为负数？设置成`-1px` 是为了让阴影尺寸稍小于div元素尺寸，这样左右两边的阴影就不会暴露出来，实现只有底部一边有阴影的效果。从而实现分割线效果（单边边框）。
  

  ##### *6. transform: scale(0.5) 方案 - 推荐: 很灵活*

    在以上的用法种，无非逃不开一种思想，就是将1px缩小为0.5px来展示，然而。0.5px并不是所有的设备或浏览器都支持，就考虑用媒体查询或viewport将其缩放比例。其实1像素问题的产生基本发生在设置边框或分割线的时候，场景并不覆盖全局样式，因此，直接缩放需要设置的元素，才是我们真正需要的。`tranform`就能实现这个需求。

  1. 设置`height: 1px`，根据媒体查询结合`transform`缩放为相应尺寸。

  

  ```css
  div {
      height:1px;
      background:#000;
      -webkit-transform: scaleY(0.5);
      -webkit-transform-origin:0 0;
      overflow: hidden;
  }
  ```

  2.用`::after`和`::befor`,设置`border-bottom：1px solid #000`,然后在缩放`-webkit-transform: scaleY(0.5);`可以实现两根边线的需求

  

  ```css
  div::after{
      content:'';width:100%;
      border-bottom:1px solid #000;
      transform: scaleY(0.5);
  }
  ```

  3.用`::after`设置`border：1px solid #000; width:200%; height:200%,`然后再缩放`scaleY(0.5);` 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加`active`比较麻烦。

  

  ```css
  .div::after {
      content: '';
      width: 200%;
      height: 200%;
      position: absolute;
      top: 0;
      left: 0;
      border: 1px solid #bfbfbf;
      border-radius: 4px;
      -webkit-transform: scale(0.5,0.5);
      transform: scale(0.5,0.5);
      -webkit-transform-origin: top left;
  }
  ```

  ##### # 6.5 媒体查询 + transfrom 对方案1的优化

  

  ```css
  /* 2倍屏 */
  @media only screen and (-webkit-min-device-pixel-ratio: 2.0) {
      .border-bottom::after {
          -webkit-transform: scaleY(0.5);
          transform: scaleY(0.5);
      }
  }
  
  /* 3倍屏 */
  @media only screen and (-webkit-min-device-pixel-ratio: 3.0) {
      .border-bottom::after {
          -webkit-transform: scaleY(0.33);
          transform: scaleY(0.33);
      }
  }
  ```

# 9. vue-cli 2.0 和 3.0 的区别

2.0 vue init webpack projectName  创建项目
3.0 新加入了 TypeScript 以及 PWA 的支持

1. 部分命令发生了变化：
   下载安装 npm install -g vue@cli
   删除了vue list
   创建项目 vue create
   启动项目 npm run serve
   默认项目目录结构也发生了变化：
   移除了配置文件目录，config 和 build 文件夹
   移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中


# 10. vue导航钩子函数 **Vue-Router导航守卫：**

有的时候，我们需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。

为此我们有很多种方法可以植入路由的导航过程：全局的, 单个路由独享的, 或者组件级的,推荐优先阅读[路由文档](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)

**全局守卫**

vue-router全局有三个守卫：

1. router.beforeEach 全局前置守卫 进入路由之前
2. router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
3. router.afterEach 全局后置钩子 进入路由之后

使用方法：

```
// main.js 入口文件``import router from ``'./router'``; ``// 引入路由``router.beforeEach((to, from, next) => { `` ``next();``});``router.beforeResolve((to, from, next) => {`` ``next();``});``router.afterEach((to, from) => {`` ``console.log(``'afterEach 全局后置钩子'``);``});
```

**to,from,next 这三个参数：**

to和from是将要进入和将要离开的路由对象,路由对象指的是平时通过this.$route获取到的路由对象。

1. next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。
2. next() 进入该路由。
3. next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。
4. next 跳转新路由，当前的导航被中断，重新开始一个新的导航。

我们可以这样跳转：next('path地址')或者next({path:''})或者next({name:''})

且允许设置诸如 replace: true、name: 'home' 之类的选项

以及你用在router-link或router.push的对象选项。

**路由独享守卫**

如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫：

```
const router = ``new` `VueRouter({`` ``routes: [`` ``{`` ``path: ``'/foo'``,`` ``component: Foo,`` ``beforeEnter: (to, from, next) => { `` ``// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖`` ``// ...`` ``}`` ``}`` ``]``})
```

路由组件内的守卫：

1. beforeRouteEnter 进入路由前
2. beforeRouteUpdate (2.2) 路由复用同一个组件时
3. beforeRouteLeave 离开当前路由时

文档中的介绍：

```
beforeRouteEnter (to, from, next) {``// 在路由独享守卫后调用 不！能！获取组件实例 `this`，组件实例还没被创建``},``beforeRouteUpdate (to, from, next) {``// 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 `this```// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，``// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。``},``beforeRouteLeave (to, from, next) {``// 导航离开该组件的对应路由时调用，可以访问组件实例 `this```}
```

**beforeRouteEnter访问this**

因为钩子在组件实例还没被创建的时候调用，所以不能获取组件实例 this，可以通过传一个回调给next来访问组件实例。

但是回调的执行时机在mounted后面,所以在我看来这里对this的访问意义不太大，可以放在created或者mounted里面。

```
beforeRouteEnter (to, from, next) {``console.log(``'在路由独享守卫后调用'``);`` ``next(vm => {`` ``// 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面，`` ``})``}
```

**beforeRouteLeave：**

导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。

```
beforeRouteLeave (to, from , next) {`` ``if` `(文章保存) {`` ``next(); ``// 允许离开或者可以跳到别的路由 上面讲过了`` ``} ``else` `{`` ``next(``false``); ``// 取消离开`` ``}``}
```

**关于钩子的一些知识：**

路由钩子函数的错误捕获

如果我们在全局守卫/路由独享守卫/组件路由守卫的钩子函数中有错误，可以这样捕获：

```
router.onError(callback => { ``// 2.4.0新增 并不常用，了解一下就可以了 `` ``console.log(callback, ``'callback'``);``});
```

在路由文档中还有更多的[实例方法](https://router.vuejs.org/zh/api/#router-实例方法)：动态添加路由等，有兴趣可以了解一下。

**跳转死循环，页面永远空白**

我了解到的，很多人会碰到这个问题，来看一下这段伪代码：

```
router.beforeEach((to, from, next) => {`` ``if``(登录){`` ``next()`` ``}``else``{`` ``next({ name: ``'login'` `}); `` ``}``});
```

看逻辑貌似是对的，但是当我们跳转到login之后，因为此时还是未登录状态，所以会一直跳转到login然后死循环，页面一直是空白的，所以：我们需要把判断条件稍微改一下。

```
if``(登录 || to.name === ``'login'``){ next() } ``// 登录，或者将要前往login页面的时候，就允许进入路由
```

**全局后置钩子的跳转：**

文档中提到因为router.afterEach不接受next函数所以也不会改变导航本身，意思就是只能当成一个钩子来使用，但是我自己在试的时候发现，我们可以通过这种形式来实现跳转：

```
// main.js 入口文件``import router from ``'./router'``; ``// 引入路由``router.afterEach((to, from) => {`` ``if` `(未登录 && to.name !== ``'login'``) {`` ``router.push({ name: ``'login'` `}); ``// 跳转login`` ``}``});
```

额，通过router.beforeEach 也完全可以实现且更好，我就骚一下。

**完整的路由导航解析流程(不包括其他生命周期)：**

1. 触发进入其他路由。
2. 调用要离开路由的组件守卫`beforeRouteLeave`
3. 调用局前置守卫：`beforeEach`
4. 在重用的组件里调用 `beforeRouteUpdate`
5. 调用路由独享守卫 `beforeEnter`。
6. 解析异步路由组件。
7. 在将要进入的路由组件中调用`beforeRouteEnter`
8. 调用全局解析守卫 `beforeResolve`
9. 导航被确认。
10. 调用全局后置钩子的 `afterEach `钩子。
11. 触发DOM更新(`mounted`)。
12. 执行`beforeRouteEnter `守卫中传给 next 的回调函数

**你不知道的keep-alive[我猜你不知道]**

在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染，[文档在这里](https://cn.vuejs.org/v2/api/#keep-alive)。

文档：和 <transition>相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。

**用法：**

缓存动态组件：

`包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。`` ```` ```` ```"view"``>`` ```` ` ` ```` ```` ```if``=``"a > 1"``>`` ```else``>`` ```

**缓存路由组件：**

使用keep-alive可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，keep-alive大多数使用场景就是这种。

``` `````

**生命周期钩子：**

这篇既然是Vue钩子函数的专场，那肯定要扣题呀~

在被`keep-alive`包含的组件/路由中，会多出两个生命周期的钩子:`activated` 与` deactivated`。

文档：在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。

**activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。
**

**activated调用时机：
**

第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用：

beforeMount=> 如果你是从别的路由/组件进来(组件销毁destroyed/或离开缓存deactivated)=>mounted=> activated 进入缓存组件 => 执行 beforeRouteEnter回调

因为组件被缓存了，再次进入缓存路由/组件时，不会触发这些钩子：

// beforeCreate created beforeMount mounted 都不会触发。

所以之后的调用时机是：

组件销毁destroyed/或离开缓存deactivated => activated 进入当前缓存组件 => 执行 beforeRouteEnter回调

 // 组件缓存或销毁，嵌套组件的销毁和缓存也在这里触发

**deactivated：组件被停用(离开路由)时调用**

使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。

这个钩子可以看作beforeDestroy的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。

如果你离开了路由，会依次触发：

组件内的离开当前路由钩子beforeRouteLeave => 路由前置守卫 beforeEach =>全局后置钩子afterEach => deactivated 离开缓存组件 => activated 进入缓存组件(如果你进入的也是缓存路由)

如果离开的组件没有缓存的话 beforeDestroy会替换deactivated 

如果进入的路由也没有缓存的话 全局后置钩子afterEach=>销毁 destroyed=> beforeCreate等

那么，如果我只是想缓存其中几个路由/组件，那该怎么做？

**缓存你想缓存的路由：
**

**Vue2.1.0之前:**

想实现类似的操作，你可以：

1. 配置一下路由元信息
2. 创建两个keep-alive标签
3. 使用v-if通过路由元信息判断缓存哪些路由。

```
`` ```if``=``"$route.meta.keepAlive"``>``  ```` ```` ```` ```if``=``"!$route.meta.keepAlive"``>`` ```if` `所以下面还要创建一个未缓存的路由视图出口-->`` ```` ``//router配置`` ``new` `Router({`` ``routes: [`` ``{`` ``path: ``'/'``,`` ``name: ``'home'``,`` ``component: Home,`` ``meta: {``  ``keepAlive: ``true` `// 需要被缓存`` ``}`` ``},`` ``{`` ``path: ``'/:id'``,`` ``name: ``'edit'``,`` ``component: Edit,`` ``meta: {``  ``keepAlive: ``false` `// 不需要被缓存`` ``}`` ``}`` ``]`` ``});
```

**Vue2.1.0版本之后：**

使用路由元信息的方式，要多创建一个`router-view`标签，并且每个路由都要配置一个元信息，是可以实现我们想要的效果，但是过于繁琐了点。

幸运的是在Vue2.1.0之后，Vue新增了两个属性配合`keep-alive`来有条件地缓存 路由/组件。

**新增属性：**

- include：匹配的 路由/组件 会被缓存
- exclude：匹配的 路由/组件 不会被缓存

`include`和`exclude`支持三种方式来有条件的缓存路由：采用逗号分隔的字符串形式，正则形式，数组形式。

正则和数组形式，必须采用`v-bind`形式来使用。

缓存组件的使用方式：

```
`"a,b"``>`` ```"view"``>``` ````"/a|b/"``>`` ```"view"``>``` ````"['a', 'b']"``>`` ```"view"``>
```

但更多场景中，我们会使用keep-alive来缓存路由：

``'a'``>`` `````

匹配规则：

1、首先匹配组件的name选项，如果name选项不可用。

2、则匹配它的局部注册名称。 (父组件 components 选项的键值)

3、匿名组件，不可匹配。

比如路由组件没有name选项，并且没有注册的组件名。

4、只能匹配当前被包裹的组件，不能匹配更下面嵌套的子组件。

比如用在路由上，只能匹配路由组件的name选项，不能匹配路由组件里面的嵌套组件的name选项。

5、文档：<keep-alive>不会在函数式组件中正常工作，因为它们没有缓存实例。

6、exclude的优先级大于include

也就是说：当include和exclude同时存在时，exclude生效，include不生效。

``"a,b"` `exclude=``"a"``>```````

当组件被exclude匹配，该组件将不会被缓存，不会调用activated 和 deactivated。

**组件生命周期钩子：**

关于组件的生命周期，是时候放出这张图片了：

![img](https://files.jb51.net/file_images/article/201807/2018724100224961.png?201862410244)

这张图片已经讲得很清楚了，很多人这部分也很清楚了，大部分生命周期并不会用到，这里提一下几点：

1. ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。这里也碰到过几次，面试官问：ajax请求应该放在哪个生命周期。
2. 关于dom的操作要放在mounted里面，在mounted前面访问dom会是undefined。
3. 每次进入/离开组件都要做一些事情，用什么钩子：

不缓存：

进入的时候可以用created和mounted钩子，离开的时候用beforeDestory和destroyed钩子,beforeDestory可以访问this，destroyed不可以访问this。

**缓存了组件：**

缓存了组件之后，再次进入组件不会触发beforeCreate、created 、beforeMount、 mounted，如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中。

同理：离开缓存组件的时候，beforeDestroy和destroyed并不会触发，可以使用deactivated离开缓存组件的钩子来代替。

**触发钩子的完整顺序：**

将路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：

1. beforeRouteLeave:路由组件的组件离开路由前钩子，可取消路由离开。
2. beforeEach: 路由全局前置守卫，可用于登录验证、全局路由loading等。
3. beforeEnter: 路由独享守卫
4. beforeRouteEnter: 路由组件的组件进入路由前钩子。
5. beforeResolve:[路由全局解析守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局解析守卫)
6. afterEach:路由全局后置钩子
7. beforeCreate:组件生命周期，不能访问this。
8. created:组件生命周期，可以访问this，不能访问dom。
9. beforeMount:组件生命周期
10. deactivated: 离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。
11. mounted:访问/操作dom。
12. activated:进入缓存组件，进入a的嵌套子组件(如果有的话)。
13. 执行beforeRouteEnter回调函数next。

# 11. 计算属性和watch的区别

## 一、计算属性(computed)

### 1、说明

> 当一些数据需要根据其它数据变化时,需要进行处理才能去展示,虽然vue提供了绑定数据表达式绑定的方式,但是设计它的初衷只是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护,对于一些比较复杂和特殊的计算有可能就捉襟见肘了,而且计算的属性写在模板里也不利于项目维护
>
> computed主要的作用:
>
> - 分离逻辑(模板和数据分离)
> - 缓存值
> - 双向绑定(getter,setter)

### 2、语法格式

1. 格式

   

   ```tsx
   computed:{ [key: string]: Function | { get: Function, set: Function } }
   ```

2. 参数说明

   - key
      字符串类型
   - 值
      可以是一个方法,如果是方法默认是get操作,也可以是对象 ,设置get属性或者set属性

### 3、基础用法

1. 说明
    在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，最终返回一个结果,
    计算属性还可以依赖多个Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新,适用于**比较费时**的数据计算

2. 示例代码

   

   ```html
   <div id="app">
       <!--使用表达式的方式-->
       <p v-text="originalPrice - discountPrice"></p>
       <!--使用计算属性的方式-->
       <p v-text="currentPrice"></p>
   </div>
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   <script>
       let app = new Vue({
           el: '#app',
           data: {
                id:1,
               originalPrice:1200,
               discountPrice:200,
           },
           //计算属性
           computed: {
               // 把日期换成 常见规格格式的字符串。
               currentPrice: function () {
                   return "当前价格:" + (this.originalPrice - this.discountPrice);
               }
           }
       });
   ```

### 4、setter与getter

1. 说明
    每一个计算属性都包含一个**getter** 和一个**setter**，上面的示例都是计算属性的默认用法， 只是利用了**getter**来读取
    如果需要，也可以提供一个**setter** 函数， 当修改计算属性的值就像修改一个普通数据那样时，就会触发**setter** 函数

2. 示例代码

   

   ```html
   <div id="app1">
       <p v-text="currentPrice"></p>
   </div>
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   <script>
       let app = new Vue({
           el: '#app',
           data: {
               id: 1,
               originalPrice: 1200,
               discountPrice: 200,
           },
           //计算属性
           computed: {
                cache:false,
               // 把日期换成 常见规格格式的字符串。
               currentPrice: {
                   get: function () {
                       return "当前价格:" + (this.originalPrice - this.discountPrice);
                   },
                   // 注意必须要传递参数,否则没有意义
                   set: function (value) { 
                       //执行自定义的一下操作
                       this.discountPrice = value
                   }
               }
           }
       });
   </script>
   <!-- 
   在 console 中 输入 app.currentPrice=300 
   1> 先执行get方法改变discountPrice的值
   2> 因为数据发生改变了 所以会重新计算当前的价格, 执行get方法
   -->
   ```

3. 注意
    绝大多数情况下，我们只会用默认的`getter`方法来读取一个计算属性，在业务中很少用到`setter`,所以在声明一个计算属性时，可以直接使用默认的写法

### 5、缓存

1. 说明
    计算属性基于它们的依赖进行缓存的，只有相关依赖发生改变的时候才会重新求值，一般为响应式依赖
    什么是响应式依赖，Vue **不能检测到对象属性的添加或删除**。由于 Vue 会在初始化实例时对属性执行 `getter/setter` 转化过程，所以属性必须在 `data` 对象上存在才能让 Vue 转换它，这样才能让它是响应

2. 示例代码

   

   ```html
   <!-- 响应式依赖 -->
   <script>
       var vm = new Vue({
         data: {
           // 声明 message 为一个空值字符串
           message: ''
         },
       })
       // 响应式
       vm.message = 'Hello!'
   
       vm.v="非响应式的的值"
   </script>
   ```

   

   ```html
   <div id="app">
       <button @click="getMethodsDate">methods</button>
       <button @click="getComputedDate">computed带缓存</button>
   </div>
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   <script type="text/javascript">
       new Vue({
           el: '#app',
           methods: {
               getMethodsDate: function () {
                   console.log(new Date().toLocaleTimeString())
               },
               // 返回computed选项中设置的计算属性——computedDate
               getComputedDate: function () {
                   console.log("缓存--->" + this.computedDate)
               }
           },
           computed: {
               computedDate: function () {
                   return new Date().toLocaleTimeString()
               }
           }
       })
   </script>
   ```

### 6、与methods的区别

1. computed`只有符合：存在依赖型数据，依赖型数据发生改变这两个条件，computed才会重新计算。
    而methods下的数据，是每次都会进行计算的
2. 调用方式不一样，`computed`定义的成员像属性一样访问，
    而`methods`定义的成员必须以函数形式调用。
3. `computed`是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，
    而`methods`里的函数在每次调用时都要执行。

## 五、侦听器(watch)

### 1、说明

> 官方:当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的，watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态
>
> `watch`和我们前面介绍的`methods`相同的语法，但是有一个关键的区别。虽然嵌套属性的值确实是函数，但键的名称必须对应数据属性中的名称

### 2、语法格式

> ```tsx
> watch:{
> [key: string]: string | Function | Object }]
> ```

### 3、语法说明

1. key
    必须是Vue对象中定义的属性
2. 值
   - 值可以是一个字符串，这个字符串是方法名
   - 值可以是一个函数
   - 值也可以是一个对象，其中包含回调函数可以其他选项：比如是否深度遍历。

### 4、基础使用

1. 示例代码

   

   ```html
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   
   <script>
       let vm = new Vue({
           data: {
               test: "111",
               user: {
                   name: "码帝",
                   address: {
                       city: "大武汉"
                   }
               }
           },
           methods: {
               fun: function (val) {
                   alert(val)
               }
           },
           watch: {
               // 方法名方式 对应 methods中的函数名
               // test: 'fun',
               // 函数方式
               test: function (v1, v2) {
                   alert("新值" + v1 + "====旧值:" + v2)
               },
               /**
                *什么是深度 例如  data: {test: "111", user: {name: "码帝" ,address{city:'大武汉'}}
                * user属性对应值就是深层,一次内推
                * 如果我们监听的user属性 当user.name属性发生改变的时候 watch监听是不到,所有我们这里需要使用深层监听
                */
               //
               user: {
                   handler: function (val) {
                       alert(val.name)
                   },
                   // 是否深度监听 默认是false
                   // 如果不设置为true当我们手动设置vm.user.name = "撸帝"的时候,是监听不到的
                   deep: true
               },
               /**
                * 或者也可以使用下面的方式来监听
                * 注意键值必须是一个字符串，所以用引号括起来
                *
                */
   
               "user.address.city": function (val) {
                   alert(val)
               }
           }
       });
       vm.test = '333';
       vm.user.name = "撸帝";
       vm.user.address.city = '长沙'
   ```

   

   ```html
   <div id="app">
       <input type="text" v-model="search"/>
       <ul>
           <li v-for="result in results" v-text="result"></li>
       </ul>
   </div>
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   
   <script>
       let vm = new Vue({
           el: "#app",
           data: {
               user:{
                   name:"码帝",
               }
               search: "",
               results: [],
               
           },
           methods: {
             fun: function () {
               alert("111");
             }
           }
           watch: {
            // 使用函数
               search: function (v1, v2) {
                console.log('新值: %s, 旧值: %s', v1, v2)
                   this.results.push(v1)
               }
           }
           
       })
   </script>
   ```

### 5、与computed的区别

1. 触发条件不同
   - computed计算属性会依赖于使用它的data属性，只要是依赖的data属性值有变动，则自定义重新调用计算属性执行一次。
   - watch则是在监控的data属性值发生变动时，其会自动调用watch回调函数。
2. 应用场景不同
   1. 执行异步操作，开销较大的操作，避免堵塞主线程，使用watch。
   2. 简单且串行返回的，使用computed

# 12. ajax的优点

14.AJAX的优缺点
(1).AJAX的优点
<1>.`无刷新更新数据。`
AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。
<2>`.异步与服务器通信。`
AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。
`<3>.前端和后端负载平衡。`
AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。
`<4>.基于标准被广泛支持。`
AJAX 基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化 Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。
`<5>.界面与应用分离。`
Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。

## `(2).AJAX的缺点`

`<1>.AJAX干掉了Back和History功能，即对浏览器机制的破坏。`
在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现。
后 退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是Ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来 取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的Ajax技术解决了这个问题，在Gmail下 面是可以后退的，但是，它也并不能改变Ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐 藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）
但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，并与Ajax框架所要求的快速开发是相背离的。这是Ajax所带来的一个非常严重的问题。
一 个相关的观点认为，使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。该问题的解决方案也已出现，大部分都使用URL片断标识符（通常被称为 锚点，即URL中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应 用程序能够在更新显示内容的同时更新锚点。）这些解决方案也同时解决了许多关于不支持后退按钮的争论。
`<2>.AJAX的安全问题。`
AJAX 技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比 以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知 的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等。
`<3>.对搜索引擎支持较弱。`
对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。
`<4>.破坏程序的异常处理机制。`
至 少从目前看来，像Ajax.dll，Ajaxpro.dll这些Ajax框架是会破坏程序的异常机制的。关于这个问题，曾在开发过程中遇到过，但是查了一 下网上几乎没有相关的介绍。后来做了一次试验，分别采用Ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。
`<5>.违背URL和资源定位的初衷。`
例如，我给你一个URL地址，如果采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。
`<6>.AJAX不能很好支持移动设备`。
一些手持设备（如手机、PDA等）现在还不能很好的支持Ajax，比如说我们在手机的浏览器上打开采用Ajax技术的网站时，它目前是不支持的。
<7>.客户端过肥，太多客户端代码造成开发上的成本。
编写复杂、容易出错 ；冗余代码比较多（层层包含js文件是AJAX的通病，再加上以往的很多服务端代码现在放到了客户端）；破坏了Web的原有标准。

5.AJAX注意点及适用和不适用场景
(1).注意点
Ajax 开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。不给予用户明确的回应，没有恰当的预读数据，或者对 XMLHttpRequest的不恰当处理，都会使用户感到延迟，这是用户不希望看到的，也是他们无法理解的。通常的解决方案是，使用一个可视化的组件来 告诉用户系统正在进行后台操作并且正在读取数据和内容。
(2).Ajax适用场景
<1>.表单驱动的交互
<2>.深层次的树的导航
<3>.快速的用户与用户间的交流响应
<4>.类似投票、yes/no等无关痛痒的场景
<5>.对数据进行过滤和操纵相关数据的场景
<6>.普通的文本输入提示和自动完成的场景
(3).Ajax不适用场景
<1>.部分简单的表单
<2>.搜索
<3>.基本的导航
<4>.替换大量的文本
<5>.对呈现的操纵

# 13. 闭包，缺点，解决

闭包作用：延伸变量的作用范围。	

一个作用域可以访问另外一个函数内部的局部变量。

优点
 1.可以读取函数内部的变量
 2.可以让这些局部变量保存在内存中，实现变量数据共享。

缺点
 1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
 2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

# 打印索引值的三种方法

```js
// 方法一  DOM自定义属性
        for (var i = 0; i < lis.length; i++) {
            
            lis[i].setAttribute("index",i)
            // lis[i].getAttribute("index")
            lis[i].onclick = function () {
                this.getAttribute("index");
                console.log(this.getAttribute("index"))
            }
        }
// 方法2 对象的方法

        for (var i = 0; i < lis.length; i++) {
            lis[i].index = i
            lis[i].onclick = function () {
                console.log(this.index);
                
            }
        }
方法三  闭包的方法

        for (var i = 0; i < lis.length; i++) {
            // 写一个匿名函数的自调用
           (function (index) {
            //    var index = i 
            // 一个作用域访问另一个函数内部的变量 为闭包
               lis[index].onclick = function () {
                   console.log(index);
               }
           })(i)
        }
```

# Ajax   jQuery的写法

```js
$.ajax({
    type: '请求方式',
    url: '接口地址',
    data: '请求参数',
    dataType: '响应数据格式',
    success: function (res) {
        // res就是服务器返回的结果
    },
    beforeSend: function () {},//请求开始之前，需要做什么  (选填)
    complete: function () {},//请求结束后，执行         (选填)
    contentType: '设置请求头中的content-type的值',
    processData: '是否处理请求参数'
});
```

# 原生Ajax写法

- GET

```
//原生的Ajax请求，使用的是XMLHttpRequest对象提供的API

  // 1、实例化 XMLHttpRequest对象， request 请求
  var xhr = new XMLHttpRequest();
  //2、调用open方法，调用请求方式和url 当有参数时,写在URL后面用?隔开
  xhr.open('GET', '/common/time?username=lisi');
  //3、调用send方法，发送请求，到这一步才开始发送ajax请求
  xhr.send();
  //4、响应过程结束，接收服务器响应的结果
  xhr.onload(function() {
    console.log(xhr.response);
  })
```

- POST

```
// 1、实例化 XMLHttpRequest对象， request 请求
  var xhr = new XMLHttpRequest();
  //2、调用open方法，调用请求方式和url

	// open内的第三个参数为false时，表示为同步ajax，运行到send时，会阻塞后面的代码运行，当收到响应时再运行后续代码   不写默认为true 表示异步(常用)

  xhr.open('POST', '/common/checkUser',false);
  //3、设置请求头，固定的代码  只要写POST就写  相对于GET，多了一行
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  //4、设置响应数据格式   属性 默认为text  类似于ajax里的dataType
  xhr.responseType = 'json';
  //5、调用send方法，发送请求，到这一步才开始发送ajax请求
  xhr.send({
    '参数': '值',
    '参数': '值'
  }); //或'参数=值&参数=值'
  //6、响应过程结束，接收服务器响应的结果
  xhr.onload(function() {
    console.log(xhr.response);
  })
```

# FormData  预览选择文件

![](D:\00笔记—来于小雨\00笔记\assets\1571323292899.png)

 **$(".img-thumbnail").attr("src",url);**  把url设置为图片 src 的值

如果需要的内容不在表单元素中  可以使用`formData.append`方法 添加



# JQ选择器

```js
1、基本选择器：
#id 、element 、.class 、* 、selector1,selector2,selectorN
2、层次选择器：
ancestor descendant 、parent > child 、prev + next 、prev ~ siblings
3、基本过滤器选择器
:first 、:last 、:not 、:even 、:odd 、:eq 、:gt 、:lt 、:header 、
:animated
4、内容过滤器选择器
:contains 、:empty 、:has 、:parent
5、可见性过滤器选择器
:hidden 、:visible
6、属性过滤器选择器
[attribute] 、[attribute=value] 、[attribute!=value] 、[attribute^=value] 、[attribute$=value] 、[attribute*=value] 、[attrSel1][attrSel2][attrSelN]
7、子元素过滤器选择器
:nth-child 、:first-child 、:last-child 、:only-child
```



# 盒子的垂直居中

```css
1.son {
      position: absolute;
      /* 相对于父亲 宽高 */
      top: 50%;
      left: 50%;
      /* 相对于自身 宽高 */
      transform: translate(-50%, -50%);
    }
2. father{
     text-align: center;
     vertical-align:middle;
     display: table-cell; 
}
.son {
      vertical-align: middle;
      display: inline-block; 
}



```

```css
1.son {
      position: absolute;
      /* 相对于父亲 宽高 */
      top: 50%;
      left: 50%;
      width: 100px;
	  height: 100px;
      /* 相对于自身 宽高 */
      transform: translate(-50%, -50%);
    }
    
2 .son {
     position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			margin: auto;
			width: 100px;
			height: 100px;
}
```



# promise 函数的封装

```js
// 封装一个自己的 Promise 函数，
// 在这个函数中，3秒之后，生成一个随机数，
// 如果生成的随机数大于 0.5，则执行成功的回调。
// 否则，执行失败的回调。
function getRandomNumber() {
  return new Promise(function(resolve, reject) {
    // 异步生成随机数的过程
    setTimeout(function() {
      // 生成随机数
      const n = Math.random()
      if (n > 0.5) {
        // 成功了，执行成功的回调
        resolve(n)
      } else {
        // 失败了，执行失败的回调
        reject(n)
      }
    }, 0)
  })
}
 getRandomNumber().then(
    n => {
      console.log('生成的随机数大于 0.5，具体的值是：' + n)
    },
    n => {
      console.log('生成的随机数小于 0.5，具体的值是：' + n)
    }
  )
```

# 输入网址浏览器都干了什么

第一步 浏览器查找该域名的 IP 地址

第二步 浏览器根据解析得到的IP地址向 web 服务器发送一个 HTTP 请求

第三步 服务器收到请求并进行处理

第四步 服务器返回一个响应

第五步 浏览器对该响应进行解码，渲染显示。

第六步 页面显示完成后，浏览器发送异步请求。

# 权重等级划分：

- ###### !important;

- ###### 行内样式;

- ###### ID选择器, 权重:100;

- ###### class,属性选择器和伪类选择器，权重:10;

# 盒子模型：

```js
在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)


一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值)

解决办法 当设置为box-sizing:border-box时，将采用怪异模式解析计算；
```

# ES6

### 2 forearch和map 的区别  

###### 相同点

1.都是循环遍历数组中的每一项

2.每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）

3.匿名函数中的this都是指向window

4.只能遍历数组

###### 不同点

1.map()会分配内存空间存储新数组并返回，forEach()不会返回数据。

2.forEach()允许callback更改原始数组的元素。map()返回新的数组。

### 3 普通函数  箭头函数的区别

 1 this指向不同 

​	1.1普通函数this指向为方法调用的对象，可以通过bind，call，apply改变this的指向，

　　　将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，

　　　其 `this` 始终指向绑定的对象bind和call，apply调用方式不同，call和apply传参方式不同

​	1.2　箭头函数比函数表达式更简洁，箭头函数不会创建自己的`this,它只会从自己的作用域链的上一层继承this`

　　　bind，call，apply只能调用传递参数，不可修改this指向

3.箭头函数不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4.箭头函数不能使用 new 命令，且没有prototype属性

# position 定位

**static** **默认值**

元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。

**relative** **相对定位**  

元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留    **相对一个元素定位**

**absolute** **绝对定位**

元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。    **最近的父元素有无定位   无定位  body**

**fixed** **固定定位**

元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。	

**粘性定位 position：sticky；（css3新增属性，兼容性比较差）**

这是一个结合了 position:relative 和 position:fixed 两种定位功能于一体的特殊定位，适用于一些特殊场景。

**参照物**：

**a：在固定的时候：参照物是相对于整个浏览器窗口**

 **特点：**

**a：**相对定位和固定定位的结合体；

**b：**在没有到达指定位置的时候，是没有定位效果的（相当于相对定位）；在到达设定的位置的时候 是固定定位；

**c：**在固定的时候：参照物是相对于整个浏览器窗口

# js继承

1.原型链继承

2.借用构造函数继承

3.组合继承（组合原型链继承和借用构造函数继承）（常用）

4.原型式继承

5.寄生式继承

6.寄生组合式继承（常用）

# 数组的方法 （数组方法）

```js
arr.push()  数组后面添加元素
arr.unshift（）   数组前面添加元素
arr.pop （）数组后面删除一个元素
arr.shift（）数组前面删除一个元素
arr.splice（n，m，...） n是开始的下标，m是移除的个数 后面是加需要加的元素
arr.slice（n，m）
arr.sort()
arr.indexOf(元素) 元素存在  返回下标 元素不存在  返回-1
arr.findIndex！！!把满足条件的第一个元素的的下标返回，如找不到，返回-1；
```

# 数组的复制

```js
1，var new_arr = arr.concat( );；
2，var new_arr = arr.slice( );
3，var new_arr =  [  ];
arr.forEach(function(item,index) {
new_arr.push(item)  };
4，var new_arr = arr.filter(function(item, index) {
  return item;
  });
5方法五
var new_arr = arr.filter(function(item, index, arr) {
   满足条件的元素要返回
   条件成立的话（true ,false），会把满足条件的元素返回；
  直接使用的元素，隐式转化；
  return arr.indexOf(item) != -1;
  });
```



# 数组的遍历 (数组遍历)

```js
1. forEach(function(val, index, arr))	循环遍历数组
2. filter(function(val, index, arr))	筛选数组符合条件的 ，return出返回条件的元素  成为新的数组
3. some(function(val, index, arr)) 	查找符合条件的  找到就终止函数 返回值为布尔值
4. every(function(val, index, arr))  
```



# 对象遍历的方法

1. for......in

2. 第二种：

   1）、Object.keys（obj）

   2）、Object.values（obj）

3.第三种：使用Object.getOwnPropertyNames(obj)

```
返回一个数组，包含对象自身的所有属性（包含不可枚举属性）
遍历可以获取key和value
```

# this指向

```js
普通函数调用	window
构造函数调用	实例对象
对象方法调用	改方法的调用对象
事件绑定方法	事件源
定时器函数	window
立即执行函数	window

1. 定时器 函数中的this 指向window
2. 构造函数 指向当前new出来的实例对象
3. 普通函数 中的this 谁调用指向谁
4. 注册事件时函数中的this指向的是事件源
5. 箭头函数中的this 在定义时指向的是上下文中的this指向
6. 事件处理函数中的this 指向的是 Vue实例对象,,,(通常指向app)
7.  Vue中的箭头函数定义的 methods 其中的this 指向的是window  
```

# 改变函数内部指向（改变this指向）

```js
fun.call(函数指定的this, arg1, arg2, …参数)	
用于对象属性的继承  改变函数this指向并执行函数

fun.apply(函数指定的this, [argsArray] 参数数组的形式)
和数组在一块使用Math.max() 求数组的最大值

fun.bind(thisArg, arg1, arg2, ...)	
改变this指向  但不执行函数


相同点:  都可以改变函数内部的this指向.

区别点:  
1.call 和apply  会调用函数, 并且改变函数内部this指向.
2.call 和apply 传递的参数不一样, call 传递参数aru1, aru2..形式apply 必须数组形式[arg]
3.bind  不会调用函数, 可以改变函数内部this指向

主要应用场景:  
1.call 经常做继承. 
2.apply 经常跟数组有关系.比如借助于数学对象实现数组最大值最小值
3.bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向
	
```



# vue   数据改变   视图层无改变   解决办法

### 1. 调用内置强制更新

```js
this.$forceUpdate()
```

## 2  vm.$set 

​	Vue.set 可以设置实例创建之后添加的属性，如sex，而this.$set只能设置实例创建后存在的属性。

# Vue中$set的用法

[![img](https://upload.jianshu.io/users/upload_avatars/6759237/b4991dd4-ed66-4fe0-a20b-c8f62864fa11?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)

#### 什么情况下使用$set？

> 由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以**属性必须在 data 对象上存在**时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出想数据变化，页面不变的情况。此时需要用到$set。



```xml
<!--先看一个例子-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>vue $set</title>
<script src="https://static.runoob.com/assets/vue/1.0.11/vue.min.js"></script>
</head>
<body>
<div id="app">
  姓名：{{ name }}<br>
    年龄：{{age}}<br>
    性别：{{sex}}<br>
    说明：{{info.content}}
</div>
<!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） -->
<script>
var data = {
    name: "简书",
    age: '3',
    info: {
        content: 'my name is test'
    }
}    
var key = 'content';
var vm = new Vue({
    el:'#app',
    data: data,
    ready: function(){
        //Vue.set(data,'sex', '男')
        //this.$set('info.'+key, 'what is this?');
    }
});
<!--如果直接新增sex属性，就会出现下图情况-->
data.sex = '男'；
</script>
</body>
```

> 在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；

![img](https://upload-images.jianshu.io/upload_images/3784265-c57a5daf3832c068.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

image

## 解决办法

### 数组：



```kotlin
this.$set(Array, index, newValue)
```



```bash
由于 JavaScript 的限制，Vue 不能检测以下变动的数组：
当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue
解决：用$set方法
当你修改数组的长度时，例如：vm.items.length = newLength
解决：vm.items.splice(newLength)
```

### 对象：



```csharp
this.$set(Object, key, value)
```



```dart
有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。
但是，添加到对象上的新属性不会触发更新。
在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：

this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

# 小程序 和其他 web 的线程区别

#### 1小程序双线程   逻辑层 传染层

小程序的架构设计时，要求渲染快、加载快。渲染页面的技术主要分为三种：

1. 纯客户端原生技术渲染(纯客户端技术需要与微信代码一起编包，跟随微信发布版本，这样的开发节奏不对)；
2. 纯web技术渲染(纯web技术，那么一些复杂交互页面可能面临一些性能问题，因为Web技术中，UI和JS的脚本在单线程中，这样容易导致逻辑任务抢占UI渲染资源。)；
3. 介于客户端技术和Web技术之间（Hybrid技术）。

最终选取的是类似微信JSSDK之后这样的HyBrid技术，页面用Web技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序的页面都是使用不同的WebView渲染。

如果开发者可以直接通过JS操作界面的DOM树，那么一些敏感数据就毫无安全性可言，故微信提供了一个沙箱的环境来运行开发者的JS代码，这个环境不能有任何的浏览器先关的接口，只能通过JS解释执行环境，类似于HTML5的ServiceWorker启动另一个线程来执行JS。

但由于小程序是多WebView的架构，所以每一个页面都是不同的WebView渲染显示，所以单独创建了一个线程去执行JS，也就是逻辑层，而界面渲染的任务都在WebView线程里执行（渲染层）。即双线程模型。

#### 2 web  单线程

# vue 与小程序双向绑定的区别





### 8. token   在 Token 失效后清空本地存储中的 token 字符串

​	

1. 在 `app.wpy` 中，找到 `constructor` 构造函数，并且定义清空token的代码：

   ```js
         complete(p) {
           // 隐藏 loading 效果
           wepy.hideLoading()
           console.log(p.data.meta)
           // 在这里清除 storage 中无效的 token
           if (p.data.meta.msg === '无效token' && p.data.meta.status === 401) {
             // 如果同时满足这两个条件，证明 storage 中的 token 已经过期了
             this.globalData.token = null
             this.saveToStorage()
           }
         }
   ```

2. 在页面中，请求那些有权限的接口：

   ```js
         // 1.5 发起创建订单的请求
         const { data: res } = await wepy.post('/my/orders/create', params)
         console.log(res)
   
         // 强制页面重新渲染
         this.$apply()
   ```

   

# vue

#### 什么是生命周期

- ###### Vue实例从创建到销毁的过程，就是生命周期。

- ###### 从开始创建、初始化数据、到编译模板、挂载DOM->渲染、更新->渲染、销毁等一系列过程，称之为Vue的生命周期

1. beforeCreate  创建前   =>  在数据观测和初始化事件还未开始，可以在这加个loading事件
2. created            创建后   =>   获取data里面数据，没有DOM，在这结束loading，还做一些初始数据的获取，实现函数自执行
3. beforeMount  载入前    =>  相关的render首次被调用，把data里面的数据和模板生成HTML，但并没有挂在到页面上
4. mounted          载入后    =>   用上面编译好的html内容替换掉el所指向的DOM对象，此过程中进行ajax操作，在这发起后端请求，拿回数据，配合路由钩子做一些事情
5. beforeUpdate   更新前    =>  在数据更新之前调用，发生虚拟DOM渲染之前
6. uodated              更新后   =>  组件DOM已经更新，可以执行依赖于DOM的操作
7. beforeDestroy    销毁前   =>   在实例销毁之前调用
8. destroyed            销毁后   =>   所有的事件监听都会被移出，当前组件已被删除，清空相关内容

#### 组件传值

- 父传子

  - 子元素通过props方法接受数据

- 子传父

  - $emit方法传递参数

- 兄弟

  - 创建一个new Vue 实例，用它来传递和接受数据

  - 在需要传值的组件中用bus.$emit触发一个自定义事件，并传递参数

    在需要接收数据的组件中用bus.$on监听自定义事件，并在回调函数中处理传递过来的参数

1. 组件间的父子之间的传值
   思路：父组件调用子组件dom位置声明一个名称，然后在子组件接收这名称，便可直接调用

###### 2.组件间的子父之间的传值

思路：在子组件通过触发一个事件带值，让父组件接受这个事件，解析这个值
子组件

3.非组件间的组件间的传值（简称：EventBus）
先用例子来解释下组件间的关联：组件A比作一个路由，通过中继器(eventBus.js)让其他房子接收到信号（组件B）
思路：首先在src目录下创建一个eventBus.js文件，复制这行代码进去

```js
import Vue from 'vue'
let connect = new Vue()    // 实例
export default connect
原文链接：https://blog.csdn.net/weihaifeng163/article/details/88338822
```

# vue路由传参的三种基本方式.

先有如下场景 点击当前页的某个按钮跳转到另外一个页面去，并将某个值带过去

```csharp
<div class="examine" @click="insurance(2)">查看详情</div>
```

##### 第一种方法     页面刷新数据不会丢失



```jsx
methods：{
  insurance(id) {
       //直接调用$router.push 实现携带参数的跳转
        this.$router.push({
          path: `/particulars/${id}`,
        })
}
```

需要对应路由配置如下：



```css
{
     path: '/particulars/:id',
     name: 'particulars',
     component: particulars
   }
```

可以看出需要在path中添加/:id来对应 $router.push 中path携带的参数。在子组件中可以使用来获取传递的参数值
 另外页面获取参数如下



```csharp
this.$route.params.id
```

##### 第二种方法  页面刷新数据会丢失

通过路由属性中的name来确定匹配的路由，通过params来传递参数。



```csharp
methods：{
  insurance(id) {
       this.$router.push({
          name: 'particulars',
          params: {
            id: id
          }
        })
  }
```

对应路由配置: 注意这里不能使用:/id来传递参数了，因为组件中，已经使用params来携带参数了。



```css
 {
     path: '/particulars',
     name: 'particulars',
     component: particulars
   }
```

子组件中: 这样来获取参数



```csharp
this.$route.params.id
```

##### 第三种方法

 使用path来匹配路由，然后通过query来传递参数
 这种情况下 query传递的参数会显示在url后面?id=？



```kotlin
methods：{
  insurance(id) {
        this.$router.push({
          path: '/particulars',
          query: {
            id: id
          }
        })
  }
```

对应路由配置：



```css
{
     path: '/particulars',
     name: 'particulars',
     component: particulars
   }
```

对应子组件: 这样来获取参数



```kotlin
this.$route.query.id
```

#### v-if /v-show区别

- ###### v-if

  - 是否渲染这个标签
  - v-if是动态的向DOM树内添加或者删除DOM元素
  - v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件
  - v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译；，v-if有更高的切换消耗，不适合做频繁的切换

- ###### v-show

  - display控制node/block
  - v-show是通过设置DOM元素的display样式属性控制显隐，v-show只是简单的基于css切换；
  - v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留；v-show有更高的初始渲染消耗，适合做频繁的切换

#### vue怎么封装组件

- 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。
- 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型
  - props 中接收数据，注意props对象里面 键值 是对数据 数据类型 的规定
  - 传过来的数据只做展示，不得修改，如果想修改，再新写一个data中的变量承接做数据的再处理
- 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法
  - 父组件将 对象 数据传递给子组件，子组件直接通过$emit修改props过来的对象的值,利用事件和传递的参数修改
- 封装完毕了，直接调用即可
- 组件思想        组件思想，是封装一个独立的、可复用的功能模块

#### vue里ref获取DOM节点

- ref 就是直接获取了你的dom节点，如果是div一类的基本dom和js的document.getElementsByTagName()效果一样的，而且这样节省开销。你可以在父组件中直接 this.$refs.refTest3.selectValue.data。直接获取子组件data中的数据，或者别的数据都可以获取。但是，这个不是我们封装组件会用的东西，因为这个用在父组件。组件的思想是 独立的

#### 路由守卫

- 当路由发生变化的时候，我们想要做的事情
  - 全局守卫      全局前置守卫 router.beforeEach(fn)
  - 组件内局部
  - 路由独享的守卫

#### 解释一下vue的双向数据绑定

- 表单控件上添加v-model，视图改变驱动数据改变

#### vue的双向数据绑定的原理

- VUE实现双向数据绑定的原理就是利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。
- vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；

#### 你对mvvm开发模式的理解

- 在mvvm架构下，view和model并没有直接联系，而是通过ViewModel进行交互，Model和ViewModel之间的交互是双向的，因此view和model的数据变化会同步
  - M   model,数据模型，可以定义数据修改和操作的业务逻辑
  - V    view，UI组件，视图区域
  - VM  监听模型数据的改变和控制试图区域的行为，是一个同步view和model的对象

#### 说下你对mvvm的理解？双向绑定的理解？

- mvvm就是vm框架视图、m模型就是用来定义驱动的数据、v经过数据改变后的html、vm就是用来实现双向绑定
- 双向绑定:一个变了另外一个跟着变了，例如：视图一个绑定了模型的节点有变化，模型对应的值会跟着变

#### 请说下具体使用vue的理解？

- 1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。
- 2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。
- 3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。
- 4、js的代码无形的规范，团队合作开发代码可阅读性更高。

#### vue-router怎么配置路由

   1 .引入vue-router 

2. 定义导航
3. 定义容器
4. 实例化一个VueRouter
5. 配置路由表
6. 挂载路由

- router-link制作导航
- 设置容器 router-view
- js提供要渲染的组件选项对象
- js实例化路由new VueRouter（{}）
- js配置路由routes：[{}]
- 就是路由挂载到new vue  里面

### 怎么添加子路由

- childre:[{}]

#### 怎么获取动态路由参数

- $route.params

#### 怎么解决spa首屏加载慢的问题

- 懒加载
  - 这种优化，就是将每个组件的js代码独立出来，在使用到这个组件时，才向服务器请求文件，并且请求过一次后就会缓存下来，再次使用到这个组件时，就会使用缓存，不再发送请求
- CDN 
  - CDN引入依赖文件
- 使用服务端渲染的方式
  - 最好不说，解释太麻烦

#### 用vue-cli初始化项目的命令是什么

- vue init webpack 项目名

#### vue-cli启动项目的命令是什么

- npm run dev

#### 配置路由没有问题，但是组件没有渲染出来有几种原因

- router-view 容器没写
- template没有一个根标签
- 路由未挂载

#### vue全家桶是什么

- Vue-cli  项目构建工具
- vue-router  路由
- vuex  状态管理
- axios  http请求工具
- webpack

#### vue和jquery有什么区别

- jquery

  - jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象

- vue

  - Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM

  - 核心特性

    - 双向数据绑定

    - 通过 指令 扩展了 HTML，通过 表达式 绑定数据到 HTML

    - 解耦视图与数据

      - js->只能看到数据

        view（视图）里面只有标签

    - 可复用组件

      - 组件：封装html/css/js 三部分  以前只封装了js

    - 虚拟DOM 

      - 操作DOM（真实DOM）-> attr/classname等
      - 虚拟DOM->js对象-重量要比真实DOM轻很多
      - M-V-vM    M(model数据)-V（view视图）-VM（视图模型）

    - 数据驱动视图

      - 视图使用数据-》{{数据}}->数据变化->视图自己变化

#### 路由之间怎么进行跳转

- 声明式
- 编程式
  - this.$router.push({name:'组件名')};

#### 你是怎么认识vuex的     大型项目   页面大于45页 接口大于200个

- vueX本质上是一个数据状态管理仓库，当同一个数据需要在多个视图上使用时，传统的组件通信较为复杂，不便于维护，就需要vuex集中管理这些数据

  1、vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。

  2、通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。

  3、应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。

#### vuex有哪几种属性

- state       声明定义数据
- getters     存放有依赖关系的数据，类似于computed计算属性
- mutations  同步的修改state中数据
- actions   异步修改数据
- modules   让每一个模块都拥有自己的state、getters、mutations、actions，方便管理

#### 说一下你的vue项目为什么使用axios不使用jquery的$ajax 和原生ajax

- vue是虚拟DOM操作的   jquery.ajax 和ajax都需要操作DOM  官方不推荐，而且axios本身就可以解决 回调地狱的问题

#### 说一下computed和methods以及watch的区别

- computed    computed是在HTML DOM加载后马上执行的，如赋值；
- methods    methods则必须要有一定的触发条件才能执行，如点击事件
- watch    检测一个数据的变化
- 执行顺序  先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。

#### 你在项目中axios是怎么样配置路径的

- 入口文件中（main.js）

  - 1导入axios组件

    2配置信息

    3挂载vue原型中

#### 你是怎么考虑vue不利于seo**优化问题的**

- 问题看待
  - 用vue不一定要做成SPA 可以直接拿Vue代替jQuery做常见的交互增强
  - 对于真正适合做SPA的项目，seo反而通常不是问题，app本身需要登录才能用，SEO没意义
- 也可以这么回答：就说我做的项目是后台管理系统，是内部用的，没考虑SEO优化的问题，但是之前我也了解到可以用服务端渲染 
- 解决方法（不会就不要说）
  - 页面预渲染
  - 服务端渲染
  - 路由采用h5 history模式

#### 你用vue里面的过滤器实现了什么功能

- 时间处理
- 金额（价格）处理

#### vue为什么在new实例化的时候data是一个对象，在组件中是一个函数

- 每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变
- 而data是函数的话，每个vue组件的data都因为函数有了自己的作用域，互不干扰。

#### 说一下mvvm和mvc的区别

- MVVM实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变

#### 谈谈你对webpack配置的理解

- 一个模块打包工具 它能够很好地管理、打包Web开发中所用到的 HTML、JavaScript、CSS

  以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源， webpack有对应的模块加载器，去安装一些loader去解析

#### vue-router路由的两种实现模式，但是vue-router默认的是hash模式

- hash模式

  - 符号#以及#后面的字符被称为hash 用windows.location.hash获取
  - hash模式的工作原理是hashchange事件，可以在window监听hash的变化

- history模式

  - 采用h5新特性，且提供了两个新方法，可以对浏览器的历史记录栈进行修改

    - pushState（）
    - replaceState（）

  - 这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面，这种模式需要后台配置支持

    - const router = new VueRouter({

      mode: 'history',

      routes: [...]

#### vue怎么实现组件缓存

- 组件缓存用的用在来回切换组件的时候

  - 1、可以在router中设置router的元信息meta

    ```js
    列如：routes: [
        {
          path: '/',
          name: 'Hello',
          component: Hello,
          meta: {
            keepAlive: true // 需要缓存
          }
        },
     !-- 正则表达式 (使用 `v-bind`) -->
  <keep-alive :include="/a|b/">
    ```

  - 、在页面中判断是否有$route.meta.keepAlive是否是true，如果是true，则进行缓存
  
    - 给组件添加<keep-alive></keep-alive>

## keep-alive 触发了两个钩子函数

```
activated      触发时机：keep-alive组件激活时使用；
deactivated    触发时机：keep-alive组件停用时调用；
```



#### axios怎么实现同步的请求

- 这个是通过async配合await的

#### vue-router是干什么的，原理是什么？

vue-router是Vue.js框架的路由插件  更新视图但不重新请求页面 

（1）利用URL中的hash("#");

（2）利用History interface在HTML5中新增的方法;

## js

#### 谈谈你对原型/原型链的理解

- 每个构造函数一旦创建都有prototype指针指向它的原型对象（构造函数.prototype）。而原型对象（构造函数.prototype）会默认生成一个constructor指针又指向构造函数。
- 原型的作用
  - 资源共享，节约空间，实现继承
  - 任何一个构造函数都有一个prototype属性，是一个对象，都有一个construction属性指向prototype所对的函数
  - 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__
  - 所有实例都间接或直接继承了原型对象的成员
- 原型链
  - 首先从对象实例本身开始
  - 如果在实例中找到了具有给定名字的属性，则返回该属性的值
  - 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性
  - 如果在原型对象中找到了这个属性，则返回该属性的值

#### 什么是闭包，在哪用过闭包，闭包的使用场景是什么

- 闭包是什么
  
  - 闭包就是能够读取其他函数内部变量的函数。
- 在哪用过闭包
  
  - 需要获取函数内部变量时
- 闭包的使用场景是什么
  
  - 闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，
- 闭包的优点
  - （1）逻辑连续，当闭包作为另一个函数调用参数时，避免脱离当前逻辑而单独编写额外逻辑。
  - （2）方便调用上下文的局部变量。
  - （3）加强封装性，是第2点的延伸，可以达到对变量的保护作用。
- 使用闭包的注意点（缺点）
  - （1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
  - （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
  
- 怎么实现继承
  - 原型链继承
    - 将父类的实例作为子类的原型  继承父类方法
  - 构造继承
    - 利用call或者apply把父类中通过this指定的属性和方法复制（借用）到子类创建的实例中
  - 组合继承
    - 通过调用父类构造，继承父类的属性并保留传参的优点，然后再通过将父类实例作为子类原型，实现函数复用

#### 栈和堆的区别

- 栈
  - 栈的特性：先进后出，主要为一个线程独享，为这个线程的函数的调用服务的。用于存放返回地址，零时变量个参数而用
  - 一般是由系统分配变量内存，只有2M大小，Linux有8M，相对来说不是太大，空间由高地址向低地址分配
  - 由系统自己分配，速度较快，但是程序员无法掌握。
- 特点
  - 堆的大小相对于操作虚拟空间，所有操作空间比较灵活，但相对来说速度也变慢了
  - 栈虽说分配的内存比较少，但速度也快了很多
- 堆
  - 堆的分配和释放是由程序员来分配和释放。在windows系统里面一般是小于2G的。因为系统是用链表来实现空闲地址空间的，
  - 堆的空间分配一般是由低地址向高地址分配
  - 一般有两种方法来申请内存，new、和malloc，new是一种运算符而malloc是函数。由程序员申请出来的内存一般速度比较慢，而却容易产生内存碎片，不过用起来比较方便。 

- 

#### HTTPS相比于http协议的优缺点

- 优点
  - 相对于http，HTTPS可以提供更加优质的保密信息，保证用户数据的安全性，此外HTTPS也在一定程度上保护了服务端，让使用恶意的攻击和伪装的成本大大提高
- 缺点
  - 缺点也同样明显，那就是HTTPS的技术门槛很高，个人和私人网站难以支撑，而且还收费，对于服务端来说也是有负担的，因为他需要更多的资源来支撑，相对来说，http网站还是在大量使用的

## jsonp原理（面试会碰到）

> 虽然这个方案现在用的越来越少，但是面试还是挺爱问的

1. script标签的src属性，可以发送请求，没有`同源限制`
2. 和`Ajax`一点关系都木有：
   1. `network`中选到`xhr`分类，什么都看不到
3. 本质是动态创建了一个`script`标签添加到页面顶部
   1. src设置的:`接口地址`+`发送的数据`+`callback=xxx`
4. 请求成功之后会被自动移除
5. 服务器返回了:函数的调用`函数名({对象})`
6. 内容返回到浏览器之后会被解析为`js`，调用定义好的函数，传入了一个参数

jQuery的jsonp

![1572228409990](D:/A就业知识/08--Node.js/Node.js-Day04/01-教学资料/assets/1572228409990.png)

自己写jsonp

![1572228673181](D:/A就业知识/08--Node.js/Node.js-Day04/01-教学资料/assets/1572228673181.png)

注意：

1. 工作中肯定是用jQ的
2. 自己写需要
   1. 创建标签
   2. 声明函数
   3. 可能还需要自行移除标签
   4. 这些`jQ`都帮你干好了
3. 虽然是民间的解决方案，但是很好用，广大程序员就做好了约定
4. 你必须发送`callback`
5. 后端也是通过`callback`去获取方法名字
6. 缺点:
   1. 不支持`post`请求
   2. 数据大的话，搞不定，文件上传搞不定
7. 流行的原因:
   1. `兼容性`好到令人发指

## 一、jsonp跨域原理

利用script标签的异步加载特性实现给服务端传一个回调函数，服务器返回一个传递过去的回调函数名称的JS代码。即：利用script标签的src属性，通过动态创建一个script标签，指定src属性为跨域的api，那么html会把返回的字符创当作javascript代码来进行解析，如果我们在返回的字符串中使用自定义函数形式包装起来，然后在html中调用自定义函数，即可拿到返回的字符串。

## 二、优点

能够直接访问响应文本，可用于浏览器与服务器间的双向通信。

## 三、缺点

JSONP从其他域中加载代码执行，其他域可能不安全；难以确定JSONP请求是否失败。

## 四、手动实现jsonp

1、 挂载回调函数

2、 将data转化成url字符串的形式

3、 处理url地址中的回调参数

4、 创建一个script的标签

5、 将script标签放到页面中

##### // 手动实现jsonp跨域

```js
 ;(function(window, name){
        var jsonp = function(url, param, callback){
            var callbackSuffix = Math.random().toString().replace('.', '');
            // console.log(callbackSuffix);  // 07626840955849186
            var callbackName = "callback_function" + callbackSuffix;
            // console.log(callbackName); // callback_function07626840955849186
            window[callbackName] = callback;
            var queryString = url.indexOf('?') == -1 ? "?" : '&';
            // console.log(queryString); // ?
            for(var key in param){
                queryString += key + '=' + param[key] + '&';
            }
            // console.log(queryString); // ?count=10&start=15&
            queryString += 'callback=' + callbackName;
            // console.log(queryString); // ?count=10&start=15&callback=callback_function07626840955849186
            var scriptElement = document.createElement('script');
            scriptElement.src = url + queryString;
            document.body.appendChild(scriptElement);
        };
        window.$jsonp = jsonp; 
    })(window, document);
```



###### 测试例子：

```js
<div id="result"></div>

// 使用
(function(){
    $jsonp('http://api.douban.com/v2/movie/in_theaters', {count:10, start:15}, function(data){
        document.getElementById('result').innerHTML = JSON.stringify(data);
    });
})();
```

## 五、使用：jquery+ajax+jsonp

```js
$.ajax({
      type : "get",
      async: false,
      url : "ajax.ashx",
      dataType : "jsonp", // 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断
      jsonp: "callbackparam",  //传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)
      jsonpCallback:"success_jsonpCallback",  //自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名
      success : function(json){
          alert(json);
          alert(json[0].name);
      },
      error:function(){
           alert('fail');
      }
 });
```



原文链接：https://blog.csdn.net/ganyingxie123456/article/details/78142171

## 跨域方案 - CORS(目前最为流行的方案)

> 需要后端配合
>
> 目前最为常用的一种跨域解决方案

传送门: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS 

1. CORS:
   1. cross:跨
   2. origin：域
   3. resource：资源
   4. sharing：共享
2. 目前用的最多的
3. `HTML5`中推出的新标准，低版本浏览器不支持`ie`

用起来简单到令人发指：

1. 前端：什么事不不用干
2. 后端：设置允许跨域
   1. express中：
      1. 响应数据之前：设置一个允许的header
      2. ` response.header('Access-Control-Allow-Origin', '*');`
   2. 无论用什么开发的后端：都需要设置上面类似的内容，才可以允许前端访问



注意：

1. CORS原理：
   1. 浏览器能够识别` ('Access-Control-Allow-Origin', '*');`这个header
   2. 请求发给服务器之后
   3. 服务器返回的响应头中有一个允许的标记
   4. 浏览器就认为服务器允许跨域访问，没有了跨域的错误
2. 缺点：
   1. 兼容性比`jsonp`差一些
   2. 微软已经放弃`xp` `ie5,ie6`基本没人用
3. 优点:
   1. get和post都支持
   2. 前端什么都不用干
4. 无论是jsonp还是`cors`一定需要后端配合
5. 纯前端在`正常情况下无法跨域`

# JSON Server

- JSON Server 是一个提供测试环境接口的工具，它可以帮我们快速生成一套接口服务，专门用于学习测试。
- 它是免费开源的命令行工具

# axios

- [axios](https://github.com/axios/axios) 是一个基于 Promise 的第三方 HTTP 客户端请求库，可以用于浏览器或者 Node.js。
  axios 本身和 Vue 没有一毛钱关系，只是简单纯粹的封装了 HTTP 请求功能。可以运行在任何支持 JavaScript 环境的平台。

#### 单页应用-SPA的特点

> **`目标`**  掌握SPA的特点 single  page  application
>
> - 传统模式 每个页面及其内容都需要从服务器一次次请求  如果网络差, 体验则会感觉很慢
> - spa模式, **`第一次`**加载 会将所有的资源都请求到页面 **`模块之间切换`**不会再请求服务器
>
> SPA优点

1. 用户体验好,因为前段操作几乎感受不到网络的延迟
2. 完全组件化开发 ,由于只有一个页面,所以原来属于一个个页面的工作被归类为一个个**`组件`**.

> 缺点

1. **`首屏`**加载慢->**`按需加载`** 不刷新页面 只请求js模块
2. 不利于SEO->**`服务端渲染`**(node->自己写路由->express-art-template+res.render())
3. **`开发难度高`**(框架) 相对于传统模式,有一些学习成本和应用成本

> vue适合开发SPA->什么是SPA+SPA特点
>
> SPA不利于SEO->搜索引擎排名靠前->搜素引擎机制->搜索引擎不能去找到局部刷新的网站内容

## 基础-单页应用-SPA-实现原理

> **`目标`** 掌握前段SPA的实现原理
>
> - SPA要实现 能够在前端自由切换模块 
> - SPA要能记忆当前切换的模块,并且刷新页面模块依然还在当前视图
> - SPA要实现在前端切换模块时,不能引起页面刷新,否则页面内容会被重置
>
> **`结论`**
>
> - 可以通过页面地址的锚链接来实现spa
> - hash(锚链接)位于链接地址 **`#`**之后
> - hash值的改变**`不会触发`**页面刷新
> - hash值是url地址的一部分,会存储在页面地址上 我们可以获取到
> - 可以通过**`事件监听`**hash值得改变
> - 拿到了hash值,就可以根据不同的hash值进行不同的**`模块切换`**

## 路由-vue-router-文档

> **`目标`**  了解vue-router是什么
>
> - Vue-Router 是 [Vue.js](http://cn.vuejs.org/) 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建**单页面**应用变得易如反掌   它是一个插件
> - Vuejs中不包含vue-router
> - 实现根据不同的请求地址 而**`显示不同的组件`**
> - 如果要使用 vue开发项目,前端路由功能**`必须使用`**vue-router来实现
>
> #### -路由-vue-router-体验及使用步骤
>
> <!-- 1 引入vue-router -->
>
> <!-- 2. 定义导航 -->
>
> <!-- 3. 定义容器 -->
>
> <!-- 4 实例化一个VueRouter -->
>
> <!-- 5 配置路由表  一个地址 => 一个组件(模块) -->
>
> <!-- 6 挂载路由 -->

#### **路由-vue-router-编程式导航`**

- 跳转不同的组件 不仅仅可以用router-link 还可以采用**`代码行为`**
- (Vue实例/组件实例)**`this.$router`** 可以拿到当前路由对象的实例
- 路由对象的实例方法 有 push  replace, go()  
- push 方法 相当于往历史记录里推了一条记录 如果点击返回 会回到上一次的地址
- replace方法 想相当于替换了当前的记录  历史记录并没有多 但是地址会变
- go(数字) 代表希望是前进还是回退,当数字大于0 时 就是前进 n(数字)次,小于0时,就是后退n(数字)次
- 可以通过vue实例 获取当前的路由实例 $router 

### 面试题

```js
// 封装一个自己的 Promise 函数，
// 在这个函数中，3秒之后，生成一个随机数，
// 如果生成的随机数大于 0.5，则执行成功的回调。
// 否则，执行失败的回调。

function getRandomNumber() {
  return new Promise(function(resolve, reject) {
    // 异步生成随机数的过程
    setTimeout(function() {
      // 生成随机数
      const n = Math.random()
      if (n > 0.5) {
        // 成功了，执行成功的回调
        resolve(n)
      } else {
        // 失败了，执行失败的回调
        reject(n)
      }
    }, 0)
  })
}

/* getRandomNumber().then(
  n => {
    console.log('生成的随机数大于 0.5，具体的值是：' + n)
  },
  n => {
    console.log('生成的随机数小于 0.5，具体的值是：' + n)
  }
) */

setInterval(function() {
  getRandomNumber().then(
    n => {
      console.log('生成的随机数大于 0.5，具体的值是：' + n)
    },
    n => {
      console.log('生成的随机数小于 0.5，具体的值是：' + n)
    }
  )
}, 3000)

```

一、vue父子组件之间的传值：

简单来说，子组件通过props方法接受父组件传来的值，子组件通过$emit方法来向父组件发送数据。（具体案例可以看我之前写的博客）。

二、vue生命周期函数：

beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestroy
destroyed
ajax操作是在monted生命周期中完成的。

三、vue自定义指令：

 

1.创建局部指令

```js
var app = new Vue({
    el: '#app',
    data: {    
    },
    // 创建指令(可以多个)
    directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        }
    }
})
```





2.全局指令

```js
Vue.directive('dir2', {
    inserted(el) {
        console.log(el);
    }
})
```



3.指令的使用

<div id="app">
    <div v-dir1></div>
    <div v-dir2></div>
</div>

四、vue动态路由传值：

vue动态路由配置，vue路由传参动态路由：
　　当我们很多个页面或者组件都要被很多次重复利用的时候，我们的路由都指向同一个组件，这时候从不同组件进入一个"共用"的组件，并且还要传参数，渲染不同的数据
　　这就要用到动态路由跟路由传参了！
首先我们来了解下router-link这个组件：
　　简单来说，它是个导航器，利用to属性导航到目标组件，并且在渲染的时候会自动生成一个a标签，当然官方也有说明，加个tag标签属性就可以渲染不同的标签，可以浏览器端查看到
　　并且当一个导航器被激活的时候，会自动加上一个css的激活样式，可以全局在路由配置中设置linkActiveClass属性，属性名就是样式css名，一般写为active
　　现在基本了解了router-link，先讲一下动态路由配置吧
我们在配置路由的时候，将目标组件的路径先配置好，如：



比如多个路由都要进入List组件，这时候在配置路由路径后加个:id(id可随便取名，标识),这个属性id可以在$route.params.id中获取，例如：



当前这个child组件要进入，以上配置的id就等于on；这时候在List组件中打印出$route.params.id就可以得到这个属性值on



这个时候，不同组件进入同一目标组件时就可以得到标识跟备注了，也可以利用这个来传递一些正常的参数
接着往下看，带参数的路由，跟获取传来的参数值
当router-link被激活点击时，会将当前的to的值push到router对象当中(路由栈),所以这个值可以是string也可以是obj
传参数的时候，我们就写成对象的形式，用到v-bind的js表达式



此时整个的理解可以为：我是child组件过来的，而且我还带来了我的名字，我叫child
在List组件当中去获取这个参数值跟id的值



  

如果是不同的组件过来的，可以设置不同的id值，只要在目标组件获取属性id的值就可以了，参数就利用query.属性值来获取 

五、axios和ajax的区别：

1.区别 axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。 简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。 axios是ajax ajax不止axios。

Ajax：
Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。
Ajax = 异步 JavaScript 和 XML（标准通用标记语言的子集）。
Ajax 是一种用于创建快速动态网页的技术。
Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。

```js
$.ajax({
            url: 'http://jsonplaceholder.typicode.com/users',
            type: 'get',
            dataType: 'json',
            data: {
                //'a': 1,
                //'b': 2,
            },
            success: function (response) {
                console.log(response)；
            }
        })
```



axios：
用于浏览器和node.js的基于Promise的HTTP客户端

1. 从浏览器制作XMLHttpRequests
2. 让HTTP从node.js的请求
3. 支持Promise API
4. 拦截请求和响应
5. 转换请求和响应数据
6. 取消请求
7. 自动转换为JSON数据
8. 客户端支持防止XSRF

```js
axios({
            url: 'http://jsonplaceholder.typicode.com/users',
            method: 'get',
            responseType: 'json', // 默认的
            data: {
                //'a': 1,
                //'b': 2,
            }
        }).then(function (response) {
            console.log(response);
            console.log(response.data);
        }).catch(function (error) {
            console.log(error);
        })
```



2.优缺点： ajax： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务 axios： 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF。

六、vuex实现购物车原理：

https://blog.csdn.net/qq_37481512/article/details/92831940

七、vue路由钩子函数：

路由的钩子函数总结有6个

全局的路由钩子函数：beforeEach、afterEach

单个的路由钩子函数：beforeEnter

组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate

 

模块一：全局导航钩子函数

1、vue router.beforeEach（全局前置守卫）

beforeEach的钩子函数，它是一个全局的before 钩子函数，

（beforeEach）意思是在 每次每一个路由改变的时候都得执行一遍。

它的三个参数：

to: (Route路由对象) 即将要进入的目标 路由对象 to对象下面的属性： path params query hash fullPath matched name meta（在matched下，但是本例可以直接用）

from: (Route路由对象) 当前导航正要离开的路由

next: (Function函数) 一定要调用该方法来 resolve 这个钩子。 调用方法：next(参数或者空) ***必须调用

next(无参数的时候): 进行管道中的下一个钩子，如果走到最后一个钩子函数，那么 导航的状态就是 confirmed （确认的）

next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。

应用场景：可进行一些页面跳转前处理，例如判断需要登录的页面进行拦截，做登录跳转！！

```js
router.beforeEach((to, from, next) => {
    if (to.meta.requireAuth) {
        //判断该路由是否需要登录权限
        if (cookies('token')) {
            //通过封装好的cookies读取token，如果存在，name接下一步如果不存在，那跳转回登录页
            next()//不要在next里面加"path:/",会陷入死循环
        }
        else {
            next({
                path: '/login',
                query: {redirect: to.fullPath}//将跳转的路由path作为参数，登录成功后跳转到该路由
            })
        }
    }
    else {
        next()
    }
})

 
```



2、vue router.afterEach（全局后置守卫）

router.beforeEach 是页面加载之前，相反router.afterEach是页面加载之后

模块二：路由独享的守卫(路由内钩子)

你可以在路由配置上直接定义 beforeEnter 守卫：

 

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
```



这些守卫与全局前置守卫的方法参数是一样的。

模块三：组件内的守卫(组件内钩子)

```js
1、beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

 

const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当钩子执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`

  }
```



八、vue解决跨域问题的方法：

https://www.cnblogs.com/ldlx-mars/p/7816316.html 

九、什么方法可以替换v-model?



 



 

 

<template>
  <div id="listBox">
    <p>v-model动态监听输入的值{{value1}} <br /></p> 
    <p>使用v-model实现的监听：<input type="text" v-model="value1" ><br/></p>
    <p>v-bind:value和v-on:input动态监听输入的值{{value2}} <br /></p>
    <p>模拟v-model的方法：
      <input type="text" v-bind:value="value2" v-on:input="value2 = $event.target.value" >
    </p>
  </div>
</template>

<script>
export default {
  name: "listBox",
  data() {
    return {
      value1:'1111',
      value2:'2222',
    };
  },
  methods: {

  },
  mounted () {

  }
};
</script>

<style>
#listBox {
  width: 900px;
  margin: 0 auto;

}
 p{
   text-align: left;
    line-height:30px;
    font-weight: bold;
    font-size: 18px;
  }
  p input{
    border:solid 1px #ddd;
    line-height:30px
  }
</style>
十、如何给vue自定义组件添加点击事件？

需要在@click后面加上.native,官方对于native的解释为：

.native -——监听组件根元素的原生事件

正确写法：

<my-button  @click.native="alert1()" names="删除" v-bind:item2="btdata"></my-button>
————————————————
版权声明：本文为CSDN博主「缘飞梦」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_37481512/article/details/94400698

# React

单例模式

```js
/**
 * 单例模式
 * 定义：一个页面里边一个js类只初始化一次
 */

class Parent {
  constructor() {
    this.name = '小明';
    this.instance = null;
  }

  getName() {
    console.log(this.name)
  }
}

// 单例模式       Parent.singel() 方法
// 工厂函数：创建单例模式
Parent.singel = function () {
  debugger;
  if (!this.instance) {
    this.instance = new Parent()
  }
  return this.instance
}

```

### ES5创建类

```js
/**
 * 使用es5 创建类
 */
/**
 * 类的静态属性：不需要new，直接可以从类名上获取的属性
 * @param {*} name 
 */
function Parent(name) {
  this.name = name
}

// 原型上定义方法
Parent.prototype.getName = function () {
  console.log(this.name);
}

// 继承
function Child(name) {
  // 继承父类实例上的属性
  Parent.call(this, name)
}

// 定义静态属性
Child.sta = 100;
//  Object.create() 继承原属性的方法
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child
  }
});

var chi1 = new Child('小红');
console.log(chi1);


// Object.create() 继承原属性的方法
// 
// 

```

### ES6创建类

```js
/**
 * es6 class关键字创建类
 */

class Par {
  constructor(name) {
    this.name = name
  }

  getName() {
    console.log(this.name);
  }
}

// es6 继承：extends关键字

class Chi extends Par {
  constructor(name) {
    super(name);
    this.age = 10;
    this.setAge = function () {
      this.age = 100;
    }
  }

  // 定义属性
  other = 10;

  // 定义方法
  handler() {
    console.log(this.other);
  }

  // 定义静态属性：static关键字
  static sta = 10000;
}

let Chi2 = new Chi('小明');
console.log('es6:', Chi2);

```

###### jsx语法   背后是啥？ 创建React元素

```js
const divs = React.createElement('div', null, 100)
通过 babel 来编译转化
```



#### 有状态组件（类组件）    无状态组件（函数组件）

#### 事件绑定注意 this问题

1. 用bind()
2. 使用箭头函数

#### 表单处理  获取值  受控组件 （自己实现双向绑定）

#### 受控组件

##### react 表单里怎么获取用户输入的数据？

1.使用到受控组件 （react 知识点）

2.input => value

### React 项目中遇到的问题（小bug）

1. 轮播图中自动播放（diff 补丁）    autoplay 的值 必须是状态数据 

   - 第一次 autoplay => true
   - 第二次 有数据 --> 真数据 -->

2. 无法手动滑动

   - 别的元素（tabbar ）高度太高  点的并不是图片

3. 滑动时谷歌浏览器控制台会报错  这是浏览器自己设置的 

   1、注册处理函数时，用如下方式，明确声明为不是被动的
   window.addEventListener('touchmove', func, { passive: false })

   2、应用 CSS 属性 touch-action: none; 这样任何触摸事件都不会产生默认行为，但是 touch 事件照样触发
   原文链接：https://blog.csdn.net/csdnXiaoZou/article/details/87276026

### 合成事件（看文档）

React 提供的  合成事件

1. 不能通过返回false的方式阻止默认行为

### 登录  



## 小程序

### 微信授权登录



1  先拿到用户的授权

2 拿到授权后  wx.getuserinfo      四条数据  隐藏私密信息   必须授权才可以获得（）

用button按钮  获取授权  open-type    bindgetuserinfo  这两个属性 授权后bindgetuserinfo  回调函数 拿到隐私数据   （以前 ）微信开放能力   现在需要授权成功后   重新调用wx.getuserinfo  获取隐私数据

```
<!-- 登录后下单 -->
<van-button type="primary" size="large" class="btnlogin" open-type="getUserInfo" bindgetuserinfo="userLogin">登录后下单</van-button> 
```



3 wx.login  获取登录凭证  code

4  调用后台接口 获取成功之后的  Token  

## 小程序授权

用户点击登录按钮 获取登录成功后的token

1. 先拿到用户的授权

2. 根据用户的授权拿到用户的隐私数据

3. 调用 wx.login （）获取code

4. 调用后台接口拿到成功后的token

   注意 登录ID要用公司的ID

wx.getuserinfo() 获取 其他数据 IV 啥的 未授权 则获取不到

###### 授权

根据button按钮中的open-type的属性设置合法值 获取用户信息

通过getuserinfo  从bindgetuserinfo获取用户信息

![](D:\01笔记\小小面试题\面试知识\assets\snipaste_20200302_170914.png)

通过e.detal.userinfo 获取用户信息

### 7.支付

1. 调用后台api接口创建订单  得到订单编号

   ​	1.1判断用户是否指定了收货地址

   ​	1.2判断订单总价是否为0

   ​	1.3判断订单中商品的件数是否为0

   ​	1.4组织出订单中商品的数组（请求对象的参数）

   ​	1.5发起创建订单的请求

2. 根据得到的订单编号 调用后台api接口获取支相关的参数‘  得到支付参数

3. 调用小程序官方提供的WX.requestPayment()函数 实现支付

### 1. 简单描述下微信小程序的相关文件类型

> 微信小程序项目结构主要有四个文件类型

- `WXML`（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件
- `WXSS` (WeiXin Style Sheets)是一套样式语言，用于描述 `WXML` 的组件样式
- `js` 逻辑处理，网络请求
- `json` 小程序设置，如页面注册，页面标题及`tabBar`

> 主要文件

- `app.json` 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 `window` 背景色，配置导航条样式，配置默认标题
- `app.js` 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量
- `app.wxss` 可选

### 2. 简述微信小程序原理

> 微信小程序采用
>
> 
>
> ```
> JavaScript
> ```
>
> 、
>
> ```
> WXML
> ```
>
> 、
>
> ```
> WXSS
> ```
>
> 
>
> 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口
>
> 微信的架构，是数据驱动的架构模式，它的 `UI` 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现
>
> 小程序分为两个部分 `webview` 和 `appService` 。其中 `webview` 主要用来展现 `UI `，`appService` 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 `JSBridge` 实现通信，实现 `UI` 的渲染、事件的处理

### 3. 小程序的双向绑定和vue哪里不一样

小程序直接 `this.data` 的属性是不可以同步到视图的，必须调用：

```
this.setData({
    // 这里设置
})
```

### 4. 小程序的wxss和css有哪些不一样的地方

> `WXSS` 和 `CSS` 类似，不过在 `CSS` 的基础上做了一些补充和修改

- 尺寸单位 `rpx`

`rpx` 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 `750rpx`。如在 `iPhone6` 上，屏幕宽度为 `375px`，共有 `750` 个物理像素，则 `750rpx = 375px = 750` 物理像素

- 使用 `@import` 标识符来导入外联样式。`@import` 后跟需要导入的外联样式表的相对路径，用;表示语句结束

```
/** index.wxss **/
@import './base.wxss';

.container{
    color: red;
}
```

### 5. 小程序页面间有哪些传递数据的方法

- 使用全局变量实现数据传递

在 `app.js` 文件中定义全局变量 `globalData`， 将需要存储的信息存放在里面

```
// app.js

App({
     // 全局变量
  globalData: {
    userInfo: null
  }
})
```

使用的时候，直接使用 `getApp()` 拿到存储的信息

- 使用 `wx.navigateTo` 与 `wx.redirectTo` 的时候，可以将部分数据放在 `url` 里面，并在新页面 `onLoad` 的时候初始化

```
//pageA.js

// Navigate
wx.navigateTo({
  url: '../pageD/pageD?name=raymond&gender=male',
})

// Redirect
wx.redirectTo({
  url: '../pageD/pageD?name=raymond&gender=male',
})


// pageB.js
...
Page({
  onLoad: function(option){
    console.log(option.name + 'is' + option.gender)
    this.setData({
      option: option
    })
  }
})
```

需要注意的问题：

`wx.navigateTo` 和 `wx.redirectTo` 不允许跳转到 `tab` 所包含的页面

`onLoad` 只执行一次

- 使用本地缓存 `Storage` 相关

### 6. 小程序的生命周期函数

- `onLoad` 页面加载时触发。一个页面只会调用一次，可以在 `onLoad` 的参数中获取打开当前页面路径中的参数
- `onShow()` 页面显示/切入前台时触发
- `onReady()` 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互
- `onHide()` 页面隐藏/切入后台时触发。 如 `navigateTo` 或底部 `tab` 切换到其他页面，小程序切入后台等
- `onUnload()` 页面卸载时触发。如 `redirectTo` 或 `navigateBack` 到其他页面时

详见 [生命周期回调函数](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#生命周期回调函数)

### 7. 怎么封装微信小程序的数据请求

参考 [这里](https://segmentfault.com/a/1190000014789969)

### 8. 哪些方法可以用来提高微信小程序的应用速度

1、提高页面加载速度

2、用户行为预测

3、减少默认 `data` 的大小

4、组件化方案

### 9. 微信小程序的优劣势

> 优势

- 即用即走，不用安装，省流量，省安装时间，不占用桌面
- 依托微信流量，天生推广传播优势
- 开发成本比 `App` 低

> 缺点

- 用户留存，即用即走是优势，也存在一些问题
- 入口相对传统 `App` 要深很多
- 限制较多,页面大小不能超过2M。不能打开超过10个层级的页面

### 10. 怎么解决小程序的异步请求问题

> 小程序支持大部分 `ES6` 语法

- 在返回成功的回调里面处理逻辑
- `Promise` 异步

### 11. 小程序关联微信公众号如何确定用户的唯一性

> 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 `unionid `来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 `unionid` 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，`unionid` 是相同的

### 12. 如何实现下拉刷新

- 首先在全局 `config` 中的 `window` 配置 `enablePullDownRefresh`
- 在 `Page` 中定义 `onPullDownRefresh` 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法
- 请求返回后，调用 `wx.stopPullDownRefresh` 停止下拉刷新

参考 [这里](https://juejin.im/post/5a781c756fb9a063606eb742)

### 13. bindtap和catchtap的区别是什么

相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分

不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的

### 14. 简述下 `wx.navigateTo()`, `wx.redirectTo()`, `wx.switchTab()`, `wx.navigateBack()`, `wx.reLaunch()`的区别</h5>

- wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 `tabbar` 页面
- wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 `tabbar` 页面
- wx.switchTab()：跳转到 `abBar` 页面，并关闭其他所有非 `tabBar` 页面
- wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 `getCurrentPages()` 获取当前的页面栈，决定需要返回几层
- wx.reLaunch()：关闭所有页面，打开到应用内的某个页面

#### 15 .微信小程序与H5的区别？

答：

第一条是运行环境的不同

传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。

第二条是开发成本的不同

只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG

第三条是获取系统级权限的不同

系统级权限都可以和微信小程序无缝衔接

第四条便是应用在生产环境的运行流畅度

长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立



#### 16、怎么解决小程序的异步请求问题？

答：

在回调函数中调用下一个组件的函数：

app.js



![img](https:////upload-images.jianshu.io/upload_images/12653633-824c8667df375dd0?imageMogr2/auto-orient/strip|imageView2/2/w/575/format/webp)

index.js

![img](https:////upload-images.jianshu.io/upload_images/12653633-209a538c28820c60?imageMogr2/auto-orient/strip|imageView2/2/w/469/format/webp)

#### 17、小程序的双向绑定和vue哪里不一样？

答：

小程序直接this.data的属性是不可以同步到视图的，必须调用：

![img](https:////upload-images.jianshu.io/upload_images/12653633-a83617530c4261e9?imageMogr2/auto-orient/strip|imageView2/2/w/300/format/webp)



# *遍历对象的常用方法*

1  for in 



![img](https:////upload-images.jianshu.io/upload_images/13813405-ee26fdeecab7b451.png?imageMogr2/auto-orient/strip|imageView2/2/w/1007/format/webp)

1

2  Object.keys(obj) & Object.values(obj)



![img](https:////upload-images.jianshu.io/upload_images/13813405-f29e0cc0742ee0b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

2

注意： 第二种方法获取到的是一个数组,通过对数组进行遍历从而通过相应的键获取到对应的值;

​      但如果是对象中包含对象,需要对循环条件进行判断才能获取到深层次的值;

3  Object.getOwnProperty(obj)



![img](https:////upload-images.jianshu.io/upload_images/13813405-53eefc9a1a9635c2.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)

3

注: 方法三获取到的结果是一个数组,通过数组每一项进行遍历,从而获取到每一个对象的值;

  但如果对象的数据结构较为复杂,如对象中包含对象,则需要添加条件进行判断才能获取全部的值;

